# 泛型算法

********

<algorithm>

<numeric> 	数值泛型算法

find()

迭代器范围 值 共三个参数

返回迭代器 	实际上算法是抽象的 返回的是指向值的对象或返回一个指出元素未找到的值		两个返回值必须具有相容的类型

**算法如何工作**

就find函数来言 阐述算法的方式是抽象的 但不脱离具体实现方式

**迭代器令算法不依赖于容器**

**但算法依赖于元素类型的操作**

一个好的例子就是运算符对元素类型的支持

**算法永远不会执行容器的操作**

它们只会运行于迭代器之上

所以算法不会改变底层容器的大小

它可能改变容器中保存的元素的值

但永远不会直接删除或添加元素

讲了这么多 其实就是算法的抽象性的体现

**初始泛型算法**

 除了少数例外

标准库算法都对一个范围内的元素进行操作

元素范围称为输入范围

前两个参数总是迭代器 第一个和最后一个的下一个

**只读算法**

accumulate(迭代器范围 0)

第三个参数决定了函数中使用哪个加法运算符以及返回值的类型

**算法和元素类型**

**操作两个序列的算法**

equal(cb1,ce1,cb2)  三个迭代器

那些只接受一个单一迭代器来表示第二个序列的算法都假定第二个序列至少与第一个序列一样长

**写容器元素的算法**

fill(迭代器范围 ， 要填充元素)

关键概念 ： 迭代器参数

**算法不检查写操作**

fill_n(单个迭代器 大小 值)

不能用于空容器

**介绍back_inserter**

使用 *插入迭代器*  保证算法有足够元素空间来容纳输出数据的方法

在p358介绍

back_inserter函数

接受1个指向容器的引用 返回一个与该容器绑定的插入迭代器

解引用插入迭代器相当于调用push_back

**拷贝算法**

copy(迭代器范围 单个迭代器)

replace(迭代器范围 目的值 替代值)

replace_copy(迭代器范围 back_inserter(容器) 目的值 替代值)

容器的拷贝被替换

**重排容器元素的算法**

sort 

unique(迭代器范围) 返回指向不重复区域之后一个位置的迭代器

之后要用容器成员函数删除元素

**定制操作**

很多算法会比较元素

默认情况下 这类算法使用元素类型的运算符

标准库为这些算法定义了额外版本	允许我们提供自己定义的操作

函数重载

**向算法传递函数**

sort的第二个版本 第三个参数接受一个 *谓词*

**谓词**  	是一个可调用的表达式

其返回结果是一个能用作条件的值

标准库算法所使用的谓词分为两类

*一元谓词*		它们只接受单一参数

*二元谓词*		有两个参数

可以理解为函数指针

作为指针的函数的参数要求是迭代器解引用能转换的

因为要传参调用

sort接受二元谓词

stable_sort()		稳定性排序

partition() 接受一个谓词 对容器内容进行划分

谓词为true的值会排在容器的前半部分 false后半部分

返回一个迭代器			指向最后一个使谓词true的元素之后的位置

**lambda表达式**

