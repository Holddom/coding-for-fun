# 泛型算法

********

<algorithm>

<numeric> 	数值泛型算法

find()

迭代器范围 值 共三个参数

返回迭代器 	实际上算法是抽象的 返回的是指向值的对象或返回一个指出元素未找到的值		两个返回值必须具有相容的类型

**算法如何工作**

就find函数来言 阐述算法的方式是抽象的 但不脱离具体实现方式

**迭代器令算法不依赖于容器**

**但算法依赖于元素类型的操作**

一个好的例子就是运算符对元素类型的支持

**算法永远不会执行容器的操作**

它们只会运行于迭代器之上

所以算法不会改变底层容器的大小

它可能改变容器中保存的元素的值

但永远不会直接删除或添加元素

讲了这么多 其实就是算法的抽象性的体现

**初始泛型算法**

 除了少数例外

标准库算法都对一个范围内的元素进行操作

元素范围称为输入范围

前两个参数总是迭代器 第一个和最后一个的下一个

**只读算法**

accumulate(迭代器范围 0)

第三个参数决定了函数中使用哪个加法运算符以及返回值的类型

**算法和元素类型**

**操作两个序列的算法**

equal(cb1,ce1,cb2)  三个迭代器

那些只接受一个单一迭代器来表示第二个序列的算法都假定第二个序列至少与第一个序列一样长

**写容器元素的算法**

fill(迭代器范围 ， 要填充元素)

关键概念 ： 迭代器参数

**算法不检查写操作**

fill_n(单个迭代器 大小 值)

不能用于空容器

**介绍back_inserter**

使用 *插入迭代器*  保证算法有足够元素空间来容纳输出数据的方法

在p358介绍

back_inserter函数

接受1个指向容器的引用 返回一个与该容器绑定的插入迭代器

解引用插入迭代器相当于调用push_back

**拷贝算法**

copy(迭代器范围 单个迭代器)

replace(迭代器范围 目的值 替代值)

replace_copy(迭代器范围 back_inserter(容器) 目的值 替代值)

容器的拷贝被替换

**重排容器元素的算法**

sort 

unique(迭代器范围) 返回指向不重复区域之后一个位置的迭代器

之后要用容器成员函数删除元素

**定制操作**

很多算法会比较元素

默认情况下 这类算法使用元素类型的运算符

标准库为这些算法定义了额外版本	允许我们提供自己定义的操作

函数重载

**向算法传递函数**

sort的第二个版本 第三个参数接受一个 *谓词*

**谓词**  	是一个可调用的表达式

其返回结果是一个能用作条件的值

标准库算法所使用的谓词分为两类

*一元谓词*		它们只接受单一参数

*二元谓词*		有两个参数

可以理解为函数指针

作为指针的函数的参数要求是迭代器解引用能转换的

因为要传参调用

sort接受二元谓词

stable_sort()		稳定性排序

partition() 接受一个谓词 对容器内容进行划分

谓词为true的值会排在容器的前半部分 false后半部分

返回一个迭代器			指向最后一个使谓词true的元素之后的位置

**lambda表达式**

谓词的通用性

find_if(迭代器范围 谓词)

对迭代器范围中的每个元素调用这个谓词

它返回第一个使谓词返回非0的元素

如果不存在这样的元素 返回尾迭代器

那么对于这个谓词需要的参数 需要用到lambda表达式

**介绍lambda**

我们可以向一个算法传递任何类别的 *可调用对象*

对于一个对象或一个表达式 如果可以对其使用调用运算符（）	则称其可调用

之前两种可调用对象 函数 函数指针

其他两种 重载了函数调用运算符的类

和lambda表达式

一个lambda表达式 表示一个可调用的代码单元

我们可以将其理解为一个未命名的内联函数

与函数类似 有返回类型	参数列表 函数体

但lambda可以定义在函数内部

~~~c++
[capture list](parameter list)-> return type{function body}
//捕获列表	参数列表 尾置返回类型	函数体
~~~

我们可以忽略参数列表和返回类型	 但必须永远包括捕获列表和函数体

~~~c++
auto f = [] {return 42;};
~~~

lambda调用方式和普通函数相同

**向lambda传递参数**

lambda不能有默认参数

lambda表达式可直接作为谓词放在支持谓词的参数上

**使用捕获列表**

lambda出现在函数中 使用局部变量只能用捕获列表中指明的

**for_each算法**

可调用对象？？谓词？？

这个算法接受一个可调用对象

并对输入序列中每个元素调用此对象

捕获列表为空 是因为我们只对lambda所在函数中定义的非static变量使用捕获列表

lambda可以直接使用定义在当前函数之外的名字

~~~c++
auto sum= [](int a,int b){return a+b;};

bool ismore(int a)
{
    auto sum= [a](int b){return a+b;};
}
~~~

p349练习 值得玩味

**lambda捕获和返回**

当定义一个lambda时 编译器生成一个与lambda对应的新的（未命名）的类类型

当用auto定义一个用lambda初始化的变量时 定义了一个从lambda生成的类型的对象

从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员

**值捕获**

类似参数传递 变量的捕获方式也可以是值或者引用

~~~c++
int v1=42;
auto f=[v1]{return v1;};
vi=0;
auto j=f();	//j为42 f保存了创建它时v1的拷贝
~~~

**引用捕获**

~~~c++
int v1=42;
auto f=[v1]{return v1;};
vi=0;
auto j=f();	//j为0 f保存了v1的引用
~~~

要保证局部变量生命周期

函数返回可调用对象不能包含引用捕获

**隐式捕获**

在[]中写上 = 或者 & 告诉编译器是哪种捕获 这样在函数体能可以直接用局部变量

可以隐式显式混合使用

但[]中第一个只能是隐式(默认)

**可变lambda**

默认情况 值被拷贝的变量 lambda不会改变其值 （值捕获）如果在参数列表首加上

mutable 因此 可变lambda可以省略参数列表

**指定lambda返回类型**

如果一个lambda体包含return之外的任何语句

则编译器假定此lambda返回void 也就是不能返回值

当我们需要为一个lambda定义返回类型时

必须使用尾置返回类型

[](参数列表)->返回类型{函数体；}；



习题 count_if (迭代器范围 谓词)

谓词为真的个数

**参数绑定**

捕获列表为空的lambda表达式可以用函数代替

操作复杂的建议用函数

很多地方相同的操作建议编写函数

如何解决可调用对象必须接受一个参数 但又不止需要一个

**标准库bind函数**

看成通用的函数适配器

它接受一个可调用对象

生成一个新的可调用对象

来适应原对象的参数列表

~~~c++
auto 可调用对象 = bind(可调用对象，逗号分隔的参数列表);

~~~

当我们调用newcallable 

newcallable 会 调用 callable 并传递给它逗号分隔的参数列表

**如何具体绑定参数**

形如 _n 的名字 占位符 

**使用placeholds名字**

名字_n 都在placehs命名空间



using namespace 具体的命名空间

**bind的参数**

今日小摆
