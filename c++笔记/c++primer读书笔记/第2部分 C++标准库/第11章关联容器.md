# 关联容器

***********

关联容器支持高效的关键字查找和访问

两个主要的关联容器 map 和 set

map中的元素是一些关键字-值 对 关键字起到索引的作用 值表示与索引相关联的数据

set中每个元素只包含一个关键字 set支持高效的关键字查询操作



标准库提供8个关联容器

不同点体现在8个维度上

每个容器：

1. 要么是map 要么是 set

2. 允不允许重复关键字

3. 是否顺序保存 
4. 允许重复关键字的容器的名字中都包含单词multi 不保持关键字按顺序存储的容器的名字以 unordered 开头 



**使用关联容器**

map --关联数组

set  --关键字的简单集合

**使用map**

也是一种模板   		映射类型

如果关键字不在map中则下标运算符会先创建一个 关键字 为word 值为 0的新元素

~~~c++
    map<string,size_t> word_count;
    string word;
    while(cin>>word)
    ++word_count[word];
    for(const auto & w: word_count)
    cout<<w.first<<" occurs "<<w.second<<((w.second>1)?"times":"time")<<endl;
~~~



**使用set**

集合类型

**关联容器概述**

支持普通容器操作 但不支持顺序容器操作

关联容器的迭代器都是双向的

**定义关联容器**

定义一个map 要有关键字类型 和 值类型

定义set要有关键字类型

默认构造函数 指定类型的空容器

**初始化multimap muliset**

**关键字类型的要求**

先说有序容器

关键字类型必须定义元素比较的方法

默认使用< 来比较关键字

**有序容器的关键字类型**

严格弱序 小于等于

**使用关键字类型的比较函数**

将类类型关键字映射定义的比较函数

这样可以定义该类的关联容器

**pair类型**

pair的标准库类型 定义在头文件utility中

一个pair保存两个数据成员

类似容器

pair是一个用来生成特定类型的 *模板*

当我们创建一个pair时 我们必须提供两个类型名 pair的数据成员将具有对应的类型

一个为first 一个为second

列了一些pair的操作

**创建pair对象的函数**

make_pair(1,2);

**关联容器操作**

先是定义的类型

**关联容器迭代器**

当解引用一个关联容器迭代器时 会得到一个value_type的值的引用

对于map是一个pair 对于set就是它的key值

pair 的 first成员保存const的关键字

second保存值

一个map的value_type是一个pair 可以改变pair的值

但不能改变关键字成员的值

**set的迭代器是const的**

只读 不能修改

**遍历关联容器**

map和set都支持begin和end操作

获取迭代器然后遍历

遍历的结果是按字典序排列的

**关联容器和算法**

通常不对关联容器使用泛型算法

关键字是const这一特性意味不能将关联容器。。。

写入的不行

关联容器可用于只读取元素的算法

但 很多算法要求搜索序列

关联容器定义了find成员函数比泛型find要快得多

通过给定的关键字直接获取元素

通常对关联容器使用算法 是把它当作原序列或者当作一个目的位置

用copy inserter 

**添加元素**

关联容器的insert成员向容器中添加一个元素或一个元素范围

由于map和set包含不重复的关键字

因此插入一个已存在的元素对容器没有任何影响

也就是说不会实际的插入已经有了的元素

注意插入的是带有某一关键字的元素

**向map添加元素**

和上一条相关联

对map进行insert操作时

元素类型是pair

对于想插入的数据，没有一个现成的pair对象

可以在insert参数列表中创建一个pair

~~~c++
    map<string,int> word_count;
    word_count.insert({word,1});
    word_count.insert(make_pair(word,1));
    word_count.insert(pair<string,size_t>(word,1));
    word_count.insert(map<string,int>::value_type(word,1));
~~~

四种构造方式	word是个string

p384介绍了关联容器的几个插入操作

**检查insert的返回值**

对于不重复关键字的容器 返回一个pair

first是一个迭代器 second是一个bool值

**展开递增语句**

**向multiset和multimap添加元素**

一对多关系

**删除元素**

三个版本的erase

与顺序容器一样 我们可以通过传递给erase一个迭代器或一对迭代器

返回void

第三个是接收一个key_type参数

删除所有匹配给定关键字的元素

**map的下标操作**

set类型不支持

如果下标接受的索引关键字不在容器中

先创建 然后进行值初始化

成员函数 at()访问关键字为k的元素 带参数检查

若k不在则异常

**使用下标操作的返回值**

返回类型

下标运算符对map会得到其值类型

解引用是pair

**访问元素**

find 

count

lower_bound  迭代器指向第一个不小于k的元素

upper_bound 迭代器指向第一个关键字大于k的元素

equal_range	返回指向pair的迭代器	表示关键字等于k的元素的范围

若k不存在 则返回end()

**对map使用find代替下标操作**

**在multimap或multiset中查找元素**

用find 加 count 一个递增 一个数字递减

关键字相同的值存在相邻位置

**一种不同的 面向迭代器的解决方法**

用两个二分算法得到一个迭代器范围

关键字不存在返回两个相同的迭代器

这个插入位置不影响元素顺序

**equal_range函数**

这是第三种方法

直接返回一个pair first second 是一个迭代器范围

若无则都是cend

**一个单词转换的map**

一个完整的程序

需要熟悉文件流



### 无序容器

不是用比较元素符 而是用哈希函数

和关键字类型的==

**使用无序容器**

通用的可以用

**管理桶**

无序容器在存储上组织为一组桶

哈希值相同 和 关键字相同的元素在同一个桶

无序容器的性能依赖于哈希函数的质量和桶数量的大小

管理桶的函数

桶接口 桶迭代 哈希策略

**无序容器对关键字类型的限制**

要求有==

且使用一个hash<key_type> 类型的对象生成哈希值

为了很多类型定义了哈希模板

