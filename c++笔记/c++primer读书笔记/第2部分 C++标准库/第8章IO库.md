# IO库

*************

## IO类

p278

io库类型和头文件

**io类型间的关系**

标准库使我们忽略这些不同类型的流之间的差异

通过 *继承机制* 实现

派生类 基类

就是如何使用istream的 也能如何使用ifstream 和 istringstream

cin getline cout 都可以类推

**io对象无拷贝或赋值**

不能对io对象拷贝或赋值

由于不能拷贝io对象 我们不能将形参或返回类型设置为流类型

进行io操作的函数通常以**引用**方式传递和返回流

同时

读写一个io对象会改变其状态 因此 传递和返回的引用不能是const的

**条件状态**

p279

列出了io类所定义的一些函数和标志

可以访问和操纵流的 **条件状态**

```c++
int ival;
cin>>ival;
```

如果键入Boo

读操作就会失败

一个流一旦发生错误

其上（这个）后续的io操作都会失败

只有当一个流处于无措状态时

我们才可以从它读取数据 写入数据

由于流可能出错

所以我们在使用流前要检查它的状态

最简单的办法是把它当作条件

```c++
while(cin>>word)
    //ok ： 读取操作成功
```

**查询流的状态**

*iostate*类型与机器无关

提供了表达流状态的完整功能

它应作为位集合来使用

p137位集合

io库定义了4个iostate类型的constexpr值

表示特定的位模式

fail bad good bit

**管理条件状态**

流对象的rdstate返回一个iostate状态

setstate操作将给定条件置位

clear重载成员

无参数版本  iostate版本









**管理输出缓冲**

讲了输出缓冲区问题

缓冲区 

导致缓冲刷新的原因

**刷新输出缓冲区**

~~~c++
cout<<"hi"<<endl;  //输出hi和一个换行，然后刷新缓冲区
cout<<"hi"<<flush; //输出hi 然后刷新缓冲区 不附加任何额外字符
cout<<"hi"<<ends;  //输出hi和一个空字符 然后刷新缓冲区
~~~

**unitbuf 操纵符**

如果想每次输出操作后都刷新缓冲区 我们可以使用unitbuf操纵符

它告诉流在接下来的每次写操作之后都进行一个flush操作

而 *nounitbuf*操纵符则重置流

使其恢复使用正常的系统管理的缓冲区刷新机制

~~~c++
cout<<unitbuf;     //所有暑促操作后都会立即刷新缓冲区

cout<<nounitbuf;  //回到正常的缓冲方式
~~~

如果程序崩溃 输出缓冲区不会被刷新

**关联输入和输出流**

当一个输入流被关联到一个输出流时

任何试图从输入流读取数据的操作都会先刷新关联的输出流

标准库将cout和cin关联在一起

~~~c++
cin>>ival
~~~

*tie*两个重载版本

一个无参数 返回指向输出流的指针

第二个 接收指向ostream的指针 将自己关联到此osteam

解开流的关联用空指针

每个流同时最多关联到一个流

多个流可以同时关联到同一个ostream

~~~c++
cin.tie(&cout);
ostream* old_tie=cin.tie(nullptr);
cin.tie(&cerr);
cin.tie(old_tie);
~~~

**文件输入输出**

p283

文件操作

**使用文件流对象**

**使用fsteam代替iostream&**

在要求使用基类型对象的地方 我们可以用继承类型的对象来代替

接受一个iostream类型引用或指针的函数可以用一个对应的fstream类型来调用

就是文件流可以代替cin cout

**成员函数open和close**

~~~c++
ifstream in(ifile);    //explicit类型 直接初始化
//隐式调用open

ofstream out;    	//未与文件关联
out.open(ifile+".copy");   	//打开指定文件
~~~

如果open调用失败	failbit会被置位	因为调用open可能会失败

检测open是否成功是一个好习惯

别忘了close关闭文件

如果open成功good() 为true

**自动构造和析构**

文件对象的构造和析构过程

析构就是自动销毁 会自动关闭文件 不用手动close

也就是说 当一个fsteam对象被销毁时 close会自动被调用

这一点比C友好

这部分的习题未理解！！！！！  p285

**文件模式**

类比C的读写方式 rewind定位文件指针 二进制等

详细地讲了文件模式的使用 p286

**以out模式打开文件会丢弃已有数据**

ofstream对象 会覆盖

类比C不事先读入文件信息 

直接写会覆盖

文件被截断？？

什么是阶段模式

保留被ofstream打开的文件中已有的数据的唯一方法是显示指定app或in模式

**每次调用open时都会确定文件模式**

对于一个给定流

每当打开文件时

都可以改变其文件模式

app-》  append 追加

每次打开文件时都要设置文件模式

可能是显式 可能是隐式

未指定 用默认值

**string流**

**使用istringstream**

**使用ostringstream**

这里的写入是 写到对象中的string对象里

