# 动态内存

**动态内存与智能指针**    **头文件memory**

**shared_ptr类**

shared_ptr允许多个指针指向同一个对象

类似vector 智能指针也是模板

p401 shared_ptr and unique_ptr 都支持的操作

和shared 独有的操作

**make_shared函数**

类似运算符new

make_shared<T>(args)

返回一个shared指针 指向T

类似emplace

**share_ptr的拷贝和赋值**

我们可以认为每个shared都有一个关联的计数器

通常称为引用计数	无论合适我们拷贝一个

当用一个shared初始化另一个shared

作为参数传递给函数

作为函数的返回值

它所关联的计数器就会递增

当我们给shared赋予一个新值 或shared被销毁（例如一个局部的shared离开其作用域

计数器会递减

当一个shared的计数器变为0 它就会自动释放自己所管理的对象

**shared_ptr自动销毁所管理的对象**

销毁通过析构函数

**shared_ptr还会自动释放相关联的内存**

只要还有shared对象引用 那么它指向的对象内存就不会被释放

如果忘记销毁程序不再需要的shared 会浪费内存

*如果把shared放在一个容器里 如果有一些元素不需要 需要用erase删除*

**使用了动态生存期的资源的类**

为什么要使用动态内存

1 不知道需要使用多少对象

2 不知道所需对象的准确类型

3 需要在多个对象间共享数据



一荣俱荣



**直接管理内存**

new 的初始化规则

**动态分配的const对象**

分配的对象是const的 返回一个指向const的指针

**内存耗尽**

如果分配失败 会抛出一个bad_alloc 

可以 new (nothrow)int   	如果分配失败则会返回一个空指针

这种形式的new是定位new

定位new表达式允许向new传递额外的参数

<new> 头文件

**释放动态内存**

delete表达式 

销毁给定的指针指向的对象 释放对应的内存

**动态对象的生存期知道被释放为止**

**shared_ptr 和 new的结合使用**

接受指针参数的智能指针构造函数时explicit的 因此必须使用直接初始化形式

圆括号

  shared_ptr<int> p(new int(42));

默认情况 智能指针指向动态内存 默认用delete

p412 讲了如何混合使用

**不要混合使用普通指针和智能指针**

不应该用内置指针来访问一个智能指针所负责的对象

**也不要使用get初始化另一个智能指针或为智能指针赋值**

get成员函数返回一个内置指针指向传进来的智能指针管理的对象

不能对此内置指针使用delete

也不要用此内置指针再绑定到一个智能指针

会导致二次delete

**其他shared操作**

reset()操作

**智能指针和异常**

**智能指针和哑类**

哑类 没有析构函数的类

**使用我们自己的释放操作**

定义一个函数(可调用对象)	来代替默认的delete 这个 *删除器* 函数必须能够完成

这个可调用对象在初始化智能指针的时候加上就行了

shared_ptr<T> p(指针，可调用对象)

**智能指针陷阱**





**unique_ptr**

某一时刻只能有一个unique指向一个给定对象

当定义一个unique 必须绑定一个new的指针 直接初始化 圆括号

不支持普通的拷贝和赋值

独有操作 release reset

**传递unique参数和返回unique**

一个例外

我们可以拷贝或赋值一个将要被销毁的unique

最常见的就是返回一个unique

还可以返回一个局部对象unique的拷贝

这是一个特殊的拷贝 编译器执行的

**向unique传递删除器**

**weak_ptr**

是一种不控制所指向对象生存期的智能指针

它指向由一个shared管理的对象

且绑定后不增加引用计数

创建一个weak要用shared去初始化它

弱共享

不能使用weak直接访问对象

要用lock检查

**核查指针类**

**指针操作**







**动态数组**

**new和数组**

**分配一个数组会得到一个元素类型的指针**

不是真正的数组 不能用begin end 和范围for语句

**初始化动态分配对象的数组**

