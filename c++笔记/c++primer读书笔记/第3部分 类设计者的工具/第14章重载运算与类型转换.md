# 重载运算与类型转换

本章讲了运算符的重载和类类型隐式转换定义

### 基本概念

重载的运算符是具有特殊名字的函数

它们的名字由关键字operator和其后要定义的运算符号共同组成

和其他函数一样 也包含返回类型 参数列表 以及函数体

重载运算符函数的参数数量与该运算符作用的运算对象一样多

除了重载的函数调用运算符 其他重载运算符不能含有默认实参

如果一个运算符函数是成员函数

则它第一个运算对象（左侧）绑定到隐式的this指针上

因此 成员运算符函数的显式参数数量必运算符的运算对象总数少一个

对于一个运算符函数来说 它要么是类的成员 要么至少含有一个类类型的参数

只能重载 不能发明

**直接调用一个重载的运算符函数**

两种方式 直接使用重载的运算符 或 用运算符函数

**某些运算符不应该被重载**

逻辑运算符重载后无法保留运算对象求值顺序 还有短路求值的特性

以及定义了逗号和取地址运算符作用于类的情况 也不建议重载

**使用与内置类型一致的含义**

操作的逻辑相同 用重载运算符

**赋值和复合赋值运算符**

**选择作为成员或者非成员**

判断运算符是作为普通函数还是作为成员更好

1 赋值 下标 调用和成员访问箭头运算符必须是成员

2  复合赋值运算符一般来说应该是成员 但并非必须 这一点与赋值运算符略有不同

3 改变对象状态的运算符或者与给定类型密切相关的运算符 如递增 递减和解引用运算符 通常应该是成员

4 具有对称性的运算符可能转换任意一端的运算对象 例如 算术 相等性 关系

当我们把运算符定义为成员函数时 它的左侧运算对象必须是运算符所属类的一个对象

### 输入和输出运算符

**重载输出运算符<<**



**输出运算符尽量减少格式化操作**

可以控制输出细节

**输入输出运算符必须是非成员函数**

**输入输出运算符必须是非成员函数**

因为运算符作为成员函数 类会隐式成为左侧运算对象 

应该为友元





**重载输入运算符>>**

输入运算符 必须处理输入可能失败的情况 而输出运算符不需要

if语句判断 io对象

**输入时的错误**

在执行输入运算符时可能发生下列错误

1 当流含有错误类型的数据时读取操作可能失败 如要读int却写入字符串 则读取操作及后续对流的其他使用都将失败

2 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败



我们在读取完所有数据后一次性检查



**表示错误**

一些输入运算符需要左更多数据验证的工作

p279





### 算术和关系运算符

通常情况下 我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧运算对象进行转换	因为这些运算符一般不需要改变运算对象的状态

所以形参都是常量的引用

如果类定义了算术运算符 则它一般也会定义一个对应的复合赋值运算符

此时 	最有效的方式是使用复合赋值来定义算术运算符



**相等运算符**

返回bool

把相等运算符的工作委托给不相等运算符

如果某个类在逻辑上有相等性的含义 则该类应该定义 operator==

这样做可以使得用户更容易使用标准库算法来处理这个类



**关系运算符**

定义了相等运算符的类也常常包含关系运算符

特别是因为关联容器和一些算法要用到小于运算符 所以定义operator<会比较有用



通常情况下 关系运算符应该

1 定义顺序关系 令其与关联容器中对关键字的要求一致

2 如果类同时也含有==运算符的话 则定义一种关系令其与==保持一致

如果不满足== 则必有一个对象<另一个



**赋值运算符**

除了拷贝赋值和移动赋值外 标准库vector还有花括号赋值运算符

我们可以重载赋值运算符 不论形参是什么 赋值运算符都必须定义为成员函数

**复合赋值运算符**

它不非得是类的成员 不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部

### 下标运算符

下标运算符必须是成员函数

返回一个引用

最好定义常量版本和非常量版本

### 递增和递减运算符

它们改变的正好是所操作对象的状态 

所以建议将其设定为成员函数

**定义前置递增/递减运算符**

下标要判断是否越界

返回的对象的引用

**区分前置和后置运算符**

为了解决重载问题

后置版本接受一个额外的 不被使用的 int 类型的形参

当我们使用后置运算符时 编译器为这个形参提供一个值为0的实参

返回的是一个值而非引用

后置运算符可以委托前置运算符执行

因为我们不会用到int形参 所以无须为其命名

**显式地调用后置运算符**

必须为它的整型参数传递一个值

### 成员访问运算符

解引用 注意别越界

箭头委托解引用

可能有点绕

**对箭头运算符返回值的限定**

虽然重载箭头运算符本质上是函数

但它不能丢掉它最基本的含义

即 箭头是一定要获取成员的（对象的）

xxx->mem

只会发生两种情况

1 xxx是指针 ok我们直接用内置类型箭头获取其mem

2 xxx是类的一个对象

ok我们用重载箭头获取一个结果（重载箭头就一个this隐式参数）

如果获取的结果是一个指针 执行 1 

如果结果本身含有重载的箭头 则执行 2

最后 要么返回所需的内容 要么返回一些表示程序错误的信息

重载的箭头运算符 必须返回类的指针或者定义了箭头运算符的某个类的对象

### 函数调用运算符

我们可以像使用函数一样使用类 因为这样的类同时也能存储状态

函数调用运算符必须是成员函数 一个类可以定义多个不同版本的调用运算符

相互之间应该在参数数量或类型上有所区别

如果类定义了调用运算符 则该类的对象称作函数对象 因为可以调用这种对象 所以我们说这些对象的行为像函数一样

**含有状态的函数对象类**

类的其他成员被用于定制调用运算符的操作

函数对象常常作为泛型算法的实参

**lambda是函数对象**

当我们编写了一个lambda

编译器将该表达式翻译成一个未命名类的未命名对象

此类含有一个重载的函数调用运算符

默认情况下lambda不能改变它捕获的变量

**表示lambda及相应捕获行为的类的值**

