# 重载运算与类型转换

本章讲了运算符的重载和类类型隐式转换定义

### 基本概念

重载的运算符是具有特殊名字的函数

它们的名字由关键字operator和其后要定义的运算符号共同组成

和其他函数一样 也包含返回类型 参数列表 以及函数体

重载运算符函数的参数数量与该运算符作用的运算对象一样多

除了重载的函数调用运算符 其他重载运算符不能含有默认实参

如果一个运算符函数是成员函数

则它第一个运算对象（左侧）绑定到隐式的this指针上

因此 成员运算符函数的显式参数数量必运算符的运算对象总数少一个

对于一个运算符函数来说 它要么是类的成员 要么至少含有一个类类型的参数

只能重载 不能发明

**直接调用一个重载的运算符函数**

两种方式 直接使用重载的运算符 或 用运算符函数

**某些运算符不应该被重载**

逻辑运算符重载后无法保留运算对象求值顺序 还有短路求值的特性

以及定义了逗号和取地址运算符作用于类的情况 也不建议重载

**使用与内置类型一致的含义**

操作的逻辑相同 用重载运算符

**赋值和复合赋值运算符**

**选择作为成员或者非成员**

判断运算符是作为普通函数还是作为成员更好

1 赋值 下标 调用和成员访问箭头运算符必须是成员

2  复合赋值运算符一般来说应该是成员 但并非必须 这一点与赋值运算符略有不同

3 改变对象状态的运算符或者与给定类型密切相关的运算符 如递增 递减和解引用运算符 通常应该是成员

4 具有对称性的运算符可能转换任意一端的运算对象 例如 算术 相等性 关系

当我们把运算符定义为成员函数时 它的左侧运算对象必须是运算符所属类的一个对象

### 输入和输出运算符

**重载输出运算符<<**



**输出运算符尽量减少格式化操作**

可以控制输出细节

**输入输出运算符必须是非成员函数**

**输入输出运算符必须是非成员函数**

因为运算符作为成员函数 类会隐式成为左侧运算对象 

应该为友元





**重载输入运算符>>**

输入运算符 必须处理输入可能失败的情况 而输出运算符不需要

if语句判断 io对象

**输入时的错误**

在执行输入运算符时可能发生下列错误

1 当流含有错误类型的数据时读取操作可能失败 如要读int却写入字符串 则读取操作及后续对流的其他使用都将失败

2 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败



我们在读取完所有数据后一次性检查



**表示错误**

一些输入运算符需要左更多数据验证的工作

p279





### 算术和关系运算符

通常情况下 我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧运算对象进行转换	因为这些运算符一般不需要改变运算对象的状态

所以形参都是常量的引用

如果类定义了算术运算符 则它一般也会定义一个对应的复合赋值运算符

此时 	最有效的方式是使用复合赋值来定义算术运算符



**相等运算符**

返回bool

把相等运算符的工作委托给不相等运算符

如果某个类在逻辑上有相等性的含义 则该类应该定义 operator==

这样做可以使得用户更容易使用标准库算法来处理这个类



**关系运算符**

定义了相等运算符的类也常常包含关系运算符

特别是因为关联容器和一些算法要用到小于运算符 所以定义operator<会比较有用



通常情况下 关系运算符应该

1 定义顺序关系 令其与关联容器中对关键字的要求一致

2 如果类同时也含有==运算符的话 则定义一种关系令其与==保持一致

如果不满足== 则必有一个对象<另一个



**赋值运算符**

除了拷贝赋值和移动赋值外 标准库vector还有花括号赋值运算符

我们可以重载赋值运算符 不论形参是什么 赋值运算符都必须定义为成员函数

**复合赋值运算符**

它不非得是类的成员 不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部

### 下标运算符

下标运算符必须是成员函数

返回一个引用

最好定义常量版本和非常量版本

### 递增和递减运算符

它们改变的正好是所操作对象的状态 

所以建议将其设定为成员函数

**定义前置递增/递减运算符**

下标要判断是否越界

返回的对象的引用

**区分前置和后置运算符**

为了解决重载问题

后置版本接受一个额外的 不被使用的 int 类型的形参

当我们使用后置运算符时 编译器为这个形参提供一个值为0的实参

返回的是一个值而非引用

后置运算符可以委托前置运算符执行

因为我们不会用到int形参 所以无须为其命名

**显式地调用后置运算符**

必须为它的整型参数传递一个值

### 成员访问运算符

解引用 注意别越界

箭头委托解引用

可能有点绕

**对箭头运算符返回值的限定**

虽然重载箭头运算符本质上是函数

但它不能丢掉它最基本的含义

即 箭头是一定要获取成员的（对象的）

xxx->mem

只会发生两种情况

1 xxx是指针 ok我们直接用内置类型箭头获取其mem

2 xxx是类的一个对象

ok我们用重载箭头获取一个结果（重载箭头就一个this隐式参数）

如果获取的结果是一个指针 执行 1 

如果结果本身含有重载的箭头 则执行 2

最后 要么返回所需的内容 要么返回一些表示程序错误的信息

重载的箭头运算符 必须返回类的指针或者定义了箭头运算符的某个类的对象

### 函数调用运算符

我们可以像使用函数一样使用类 因为这样的类同时也能存储状态

函数调用运算符必须是成员函数 一个类可以定义多个不同版本的调用运算符

相互之间应该在参数数量或类型上有所区别

如果类定义了调用运算符 则该类的对象称作函数对象 因为可以调用这种对象 所以我们说这些对象的行为像函数一样

**含有状态的函数对象类**

类的其他成员被用于定制调用运算符的操作

函数对象常常作为泛型算法的实参

**lambda是函数对象**

当我们编写了一个lambda

编译器将该表达式翻译成一个未命名类的未命名对象

此类含有一个重载的函数调用运算符

默认情况下lambda不能改变它捕获的变量

**表示lambda及相应捕获行为的类的值**

如我们所知 当一个lambda通过引用捕获变量时 由程序负责确保lambda执行时被捕获的对象确实存在

因此 编译器可以直接使用该引用而无需在lambda产生的类中将其存储

值捕获的变量会成为lambda临时类中的数据成员

同时创建构造函数 并用捕获变量的值来初始化

#### 标准库定义的函数对象

定义了一组表示算术运算符 关系运算符 逻辑运算符的类 是模板

**在算法中使用标准库函数对象**

指针可以用这种类比较大小

花里胡哨结合 **算法 bind 函数对象**

#### 可调用对象与function

cpp中有几种可调用的对象 ：函数 函数指针 lambda表达式 bind创建的对象 已经重载了函数调用运算符的类

和其他对象一样 可调用的对象也有类型

**不同类型可能具有相同的调用形式**

调用形式就是 返回类型+参数类型



这里引出了我在c中学到的 **函数表**

用到了可调用对象的指针（函数指针）

结合map

建立映射

但除了基本的函数能直接得到指针外

其他的可调用对象有着自己的类型

这就引出

**标准库function类型**

用它来存储调用形式相同的可调用对象

这时 可以不用函数指针 而用可调用对象的指针（function类型）

这是可调用对象类型的某种统一

**重载的函数与function**

我们不能直接把重载函数的名字存入function类型的对象中

会有二义性

不妨用一个特定的函数指针来代替函数名

同样 也可用lambda来消除二义性

### 重载、类型转换与运算符

这节会学到类类型的转换 如何自定义

#### 类型转换运算符

它是类的一种 特殊成员函数

它负责将一个类类型的值转换成其他类型

~~~c++
operator type（） const;
~~~

type是某种类型

类型转换运算符 可以面向只要能作为函数返回类型的类型定义

它没有显式的返回类型 也没有形参

而且必须定义成类的成员函数

一般被定义为const

**定义含有类型转换运算符的类**

此运算符是 此类向别的类型转换

**类型转换运算符可能产生意外结果**

小心定义 会发生类型转化 如bool的算术类型 io类就有此定义

****

**显式的类型转换运算符**

为了防止上述的风险

有此

前面加一个 **explicit**

需要 static_cast<>  转换

但有例外显式的类型转换会被隐式执行

1 语句的条件部分 if while do

2 for语句

3 逻辑运算符的运算对象

4 条件运算符的条件表达式

**转换为bool**

无论我们在什么时候在条件中使用流对象

都会使用为io类型定义的operator bool

#### 避免有二义性的类型转换

通常情况下 不要为类定义相同的类型转换（A定义了转换B的，B定义了转换A的）

也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换

**实参匹配和相同的类型转换**

对于一个函数调用

使用以B为参数的A的构造函数

也可以使用B中把B转换成A的类型转换运算符

会产生二义性

如果想正确调用 要显式地调用类型转换运算符或者转换构造函数

值得注意 强制类型转换本身就有二义性 无法解决上述问题

**二义性与转换目标为内置类型的多重类型转换**

几个忠告

****

**重载函数与转换构造函数**

**重载函数与用户定义的类型转换**

#### 函数匹配与重载运算符

表达式中运算符的候选函数集既应该包括成员函数，也应该包括非成员函数

如果我们对同一个类既提供了转换目标是算术类型的类型转换 也提供了重载的运算符

则将会遇到重载运算符与内置运算符的二义性问题

