当定义一个类时，我们显式地或隐式地指定在此类型的对象拷贝 移动 赋值 和 销毁

时做什么

一个类通过物种特殊的成员函数来控制这些操作

包括 拷贝构造函数 拷贝赋值运算符 移动构造函数 移动赋值运算符

 和 析构函数

使用了这些的操作 为 拷贝控制操作





## 拷贝 赋值 与 销毁

### 拷贝构造函数

如果一个构造函数的第一个参数是本类的类型 的引用

且任何额外参数都有默认参数

这种构造函数常被隐式的使用 所以不应该是explicit的

**合成拷贝构造函数**

如果我们没有为一个类定义拷贝构造函数

编译器会为我们定义一个

与合成默认构造函数不同 

即使我们定义了其他构造函数 编译器也会为我们合成一个拷贝构造函数

合成拷贝构造函数用来阻止我们拷贝该类类型的对象

**拷贝初始化**

通常使用拷贝构造函数完成

有时用移动构造函数

1 在我们用 = 定义变量时会发生

或

2 将一个对象作为实参传递给一个非引用类型的形参

3 从一个返回类型为非引用类型的函数返回的一个对象

4 用花括号列表初始化一个数组或一个聚合类

5 容器会对它们分配的对象进行初始化 insert push都是拷贝初始化

emplace是直接初始化

**参数和返回值**

拷贝构造函数被用来初始化非引用类型的参数

为什么拷贝构造函数自己的参数必须是引用类型的

否则就是无限循环 		p442

**拷贝初始化的限制**

如果要求显式构造函数 也就是explicit

就必须临时构造一个对象 加上括号

**编译器可以绕过拷贝构造函数**

允许下面代码

~~~c++
    string null_book="000";
    //改写为下面
    string book("000");
~~~

### 拷贝赋值运算符

与类控制器对象如何初始化一样 （上面讲的就是初始化）

类也可以控制其对象如何赋值

**重载赋值运算符**

**重载运算符**  的知识

重载运算符本质上是函数

其名字由operator关键字 后接表示要定义的运算符的符号组成

赋值运算符就是一个名为operator=的函数

运算符函数也有一个返回类型 和参数列表

重载运算符的参数表示运算符的运算对象

某些运算符 包括赋值运算符必须定义为成员函数

如果一个运算符是成员函数 其左侧运算对象就绑定到隐式的this参数

对于一个二元运算符 例如赋值运算符 其右侧运算对象作为显式参数传递

拷贝赋值运算符接受一个与其所在类相同类型的参数

~~~c++
    class Foo{
        public:
        Foo& operator=(const Foo&); //赋值运算符
    };
~~~

为了与内置类型的赋值保持一致 赋值运算符通常返回一个指向其左侧运算对象的引用

标准库要求保存在容器中的类型要有赋值运算符

且其返回值是左侧运算对象的引用

**合成拷贝赋值运算符**

与处理拷贝构造函数一样

如果一个类未定义自己的拷贝赋值运算符

编译器会为它生成一个合成拷贝赋值运算符

类似拷贝构造函数

对于某些类 合成拷贝赋值运算符用来禁止该类型对象的赋值

~~~c++
    class Foo{
        public:
        Foo& operator=(const Foo& m)
        {   
            a=m.a;
            b=m.b;
            return *this;
        }
        Foo():a(0),b(0){};
        Foo(int a,int b):a(a),b(b){}
        void print()
        {
            cout<<a<<b<<endl;
        }
        private:
        int a;
        int b;
    };
    Foo m(2,3);
    Foo n;
    n=m;
    m.print();
    n.print();
~~~

### **析构函数**

析构函数执行与构造函数相反的操作

析构函数释放对象使用的资源

并销毁对象的非static数据成员

它是类的一个成员函数

名字由~号接类名构成

它没有返回值 也不接受参数

由于它不接受参数 因此他不能被重载

对于一个给定类 只会有唯一一个析构函数

**析构函数完成什么工作**

析构函数有一个函数体和一个析构部分

先执行函数体

再销毁成员

按初始化的顺序逆序销毁 （stack）

**什么时候会调用析构函数**

只要一个对象被销毁就会自动调用其析构函数

一层层的关系

我们只需直接管理的内存就是我们直接分配的内存

当指向一个对象的引用或指针离开作用域时

析构函数不会被执行

1 变量在离开其作用域

2 当一个对象被销毁时，其成员被销毁

3 容器被销毁时 其元素被销毁

4 对于动态分配的对象 当对指向它的指针应用delete运算符时被销毁

5 对于临时对象 当创建它的完整表达式结束时被销毁

**合成析构函数**

未定义析构函数 编译器会定义一个合成析构函数

析构函数体不直接销毁成员

在其之后的析构阶段隐式销毁

### **三/五法则**

如前面所述

有三个基本操作可以控制类的拷贝操作：拷贝构造函数 拷贝赋值运算符

和析构函数

在新标准下：一个类还可以定义一个移动构造函数和一个移动赋值运算符

我们可以只定义一两个 但只用到一个而不需要定义所有操作的情况是很少见的

**需要析构函数的类也需要拷贝和赋值操作**

先确定是否需要析构函数 就能确定是否要拷贝构造函数或赋值运算符

**需要拷贝操作的类也需要赋值操作，反之亦然**

需要拷贝构造函数就是需要拷贝赋值运算符

什么时候要拷贝构造？



**使用=default**

我们可以通过将拷贝控制成员定义为 =default来显式地要求编译器生成的合成的版本

当我们在类内用=default时 合成的函数隐式声明为内联的 like其他成员函数

如果我们不希望合成的成员时内联函数

应该只对成员的类外定义使用=default

我们只能对具有合成版本的成员函数使用=default

即 默认构造函数 或者 拷贝构造成员（函数 运算符）

**阻止拷贝**

大多数类应该定义默认构造函数 拷贝构造成员

无论是隐式还是显式

虽然这样 但是对于某些类来说 这些操作没用任何意义

在此情况下 定义类时必须采用某种机制阻止拷贝或复制

不是我们不去定义它了 因为编译器照样会合成一个

所以

**定义删除的函数**

cpp11

我们可以通过将拷贝构造函数和拷贝构造运算符定义为 **删除的函数**

来阻止拷贝

**删除的函数**是这样一种函数

虽然我们声明了它们 但不能以任何形式使用它们

在函数的参数列表后面加上 =delete

来指出我们希望将它定义为 **删除的**

与=default不同 =delete 必须 出现在函数第一次声明的时候

**析构函数不能是删除的成员**

我们不能删除析构函数

如果析构函数被删除 就无法销毁此类型的对象

编译器不允许创建这样的对象 和定义这样的变量

对于删除了析构函数的类型 虽然我们不能定义这种类型的变量或成员

 但可以动态分配这种类型的对象

但是不能释放这些对象（delete会调用析构函数）

**合成的拷贝控制成员可能是删除的**

对于某些类来说 编译器会将合成的成员定义为删除的函数

1 如果类的某个成员的析构函数是删除的或不可访问的（private的），则类的合成析构函数被定义为删除的

2  如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类的合成拷贝构造函数也被定义为删除的

3 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类内有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的

4 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没用类内初始化器，或类内有一个const成员，它没用类内初始化器且器类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。

这四点  本质上就是如果一个类有数据成员不能被默认构造 拷贝 复制或销毁

则对应的成员函数将被定义为删除的。

p451 总结

拷贝控制成员就是有三个 析构函数 拷贝构造函数 拷贝赋值运算符

**private 拷贝控制**

老标准 类是通过将拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝

有一点是友元和成员函数可以进行拷贝（它们可以访问private中的成员）

为了阻止它们访问，我们只声明函数 而不定义它们

但成员函数或友元函数拷贝的企图时链接时的错误 

其他的是编译时就出现错误

### 拷贝控制和资源管理

通常 管理类外资源的类必须定义拷贝控制成员

因为这种类要通过析构函数来释放对象所分配的资源 一旦一个类需要析构函数

那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符

我们给一类具有特征的类确定其语义

然后判断是否需要拷贝控制

我们区定义这些拷贝控制成员

有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针

拷贝值类 副本与原对象无关

拷贝指针类 副本和原对象使用相同的底层数据

当然也有不允许拷贝和赋值的类 如io和unique 行为不像值和指针

**行为像值的类**

**类值拷贝赋值运算符**

赋值运算符通常组合了析构函数和构造函数的操作

类似析构函数 赋值操作会销毁左侧运算对象的资源

类似拷贝构造函数 赋值操作会从右侧运算对象拷贝数据

我们要保证它是正确顺序执行的

就是即使一个对象赋予它自身，也保证正确

而且 如果可能 我们编写的赋值运算符还是异常安全的



总结 赋值运算符

1 如果将一个对象赋予它自身 赋值运算符必须能正确工作

2 大多数赋值运算符组合了析构函数和拷贝构造函数的工作

注意顺序

先将右侧数据放到临时变量中 再释放左侧数据



**定义行为像指针的类**

对于行为像指针的类 我们要定义拷贝构造函数和拷贝赋值运算符

来拷贝指针成员 而不是底层数据

也需要析构函数来释放构造函数分配的内存

但同时指向一块资源 我们就得注意释放的时机

一个好的方法就是用shared

如果想直接管理资源 使用 **引用计数**



**引用计数**

工作方式

1 除了初始化对象外 每个构造函数（拷贝构造函数除外）还要创建一个引用计数

用来记录有多少对象与正在创建的对象共享状态

创建一个对象 计数器为1

2 拷贝构造函数不分配新的计数器 而是拷贝给定对象的数据成员 包括计数器

然后递增计数器

3 析构函数递减计数器 如果为0则释放状态

4 拷贝赋值运算符递增右侧运算对象的计数器 递减左侧运算对象的计数器

如果左侧计数器为0 则要销毁

计数器可以是动态开辟的内存

**定义一个使用引用计数的类**

~~~c++
class Hasptr{
public:
    //构造函数分配的新的string和新的计数器，将计数器置为1
    Hasptr(const string &s=string()):
    ps(new string(s)),i(0),use(new size_t(1)){}
    //拷贝构造函数拷贝所有三个数据成员，并递增计数器
    Hasptr(const  Hasptr &p):
    ps(p.ps),i(p.i),use(p.use){++*use;}
    Hasptr& operator=(const Hasptr&);
    ~Hasptr();

private:
    string * ps;
    int i;
    size_t *use;//计数器

};
~~~

**类指针的拷贝成员“篡改”引用计数**

如何写引用计数的拷贝构造成员

p457题目

一个引用计数的拷贝构造成员写法

一个普通类值写法

### **交换操作**

除了定义拷贝控制成员

管理资源的类通常还定义一个名叫swap的函数

对于那些与重排元素顺序的算法一起使用的类

定义swap是非常重要的

这类算法在需要交换两个元素时会调用swap

如果一个类定义了自己的swap 那么算法将使用类的自定义版本

否则用标准库的

理解 swap

一次拷贝 两次赋值

对于一个类值 我们在交换的时候可能会分配重复的资源

不如直接交换指针

而不是一整个类

**编写自己的swap函数**

友元函数能访问private

然后声明称inline	优化代码

swap的函数体对给定对象的每个数据成员调用swap

swap较之于拷贝控制成员 不是必要

但对于分配了资源的类 是一种重要的优化手段

**swap函数应该调用swap 而不是标准库swap**

最好每个类用每个类的swap

**在赋值运算符中使用swap**

定义swap的类通常用swap来定义它们的赋值运算符

这些运算符使用了一种名为 **拷贝并交换**的技术

：将左侧运算对象与右侧运算对象的一个副本进行交换

按值传递到运算符函数

然后swap

返回this指针

这个版本的赋值运算符 参数并不是引用

记住算法会有类专有的swap

这是针对类值的

能节省空间

类指针使用std::swap函数就可以实现指针交换，节省内存空间，不需要重新自定义swap函数。因此类指针的版本不会从swap函数收益。

对于动态分配内存的例子来说，拷贝交换方式是一种简洁的设计。

### 拷贝控制示例

拷贝控制成员不只是资源管理

一些类也需要拷贝控制成员的帮助来进行薄记工作或其他操作

实现了两个类 p461

### 动态内存管理类

如果某些类需要在运行时分配可变大小的内存空间	一般应该用std容器来保存它们的数据

但是 并不是对每一个类都使用	某些类需要自己进行内存分配 这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存

这节 实现一个简化版本的vector 不使用模板 基于string

**StrVec类的设计**

使用allocator	来获得原始内存 

**移动构造函数和std：：move**

我们在重新分配内存的过程中移动而不是拷贝元素

cpp++11

两种机制避免拷贝

1 移动构造函数将资源从给定对象移动而不是拷贝到正在创建的对象

2 标准库 move函数

### 对象移动

新标准的一个最主要的特性是可以移动而非拷贝对象的能力

在对象拷贝后就被立即销毁的情况下 这会大幅度提升性能

io类和unique是不能拷贝但可移动的类

**右值引用**

为了支持移动操作 

新标准引入了一种新的引用类型 **右值引用**

所谓右值引用就是必须绑定到右值引用

我们通过 &&来获得右值引用

它有一个重要的性质 只能绑定到一个将要销毁的对象

因此我们可以自由地将一个右值引用的资源移动到另一个对象中

右值引用有着左值引用完全相反的特性

注：我们可以将一个const引用绑定到右值上

**左值持久 右值短暂**

由于右值引用只能绑定到临时对象

1 所引用的对象将要被销毁

2 该对象没有其他用户

那么 使用右值引用的代码可以自由地接管所引用的对象的资源

**变量是左值**

**右值引用的类型是左值**

**标准库move函数**

虽然不能将一个右值引用直接绑定到一个左值上

但我们可以显式地将一个左值转换为对应的右值引用类型

我们还可以通过调用move来获得绑定到左值上的右值引用

头文件 utility

move调用告诉编译器 我们有个一个左值 但我们希望像一个右值一样处理它

我们必须认识到 调用move就意味着承诺 除了对传进去的参数赋值或销毁它 我们将不再使用它

在调用move之后 我们不能对移后源对象的值做任何假设

我们可以销毁一个移后源对象 也可以赋予它新值 但不能使用一个移后源对象的值

使用move一定要用std：：move

### 移动构造函数和移动赋值运算符

为了让我们自己的类型支持移动操作 需要为其定义移动构造函数和移动赋值运算符

这两个成员类似对应的拷贝操作，但它们从给定对象 窃取 资源而不是拷贝资源





类似拷贝构造函数 移动构造函数的第一个参数是该类类型的引用 但是是右值引用

除了完成资源移动 移动构造函数还必须确保移后源对象处于这个状态：销毁它是无害的

（例如要给源对象赋成空指针之类的）

特别的 一旦资源完成移动 源对象必须不再指向被移动的资源 这些资源的所有权已经归属新创建的对象



比如要把源对象的成员设为空指针

如果不设置为空指针 那么移动后的对象可能会被销毁掉



**移动操作、标准库容器和异常**

函数通常不分配任何资源

因此移动操作通常不会抛出任何异常

当我们编写一个不抛出异常的移动操作时

我们应该通知标准库 否则它会认为移动类对象时可能会出现异常 并会做一些额外的准备

一种通知标准库的方法时在我们的构造函数中指明 *noexcept*

在参数列表后 初始化列表冒号之前

在声明和定义中都要指定

不抛出异常的移动构造函数和移动赋值运算符必须声明noexcept

为什么要声明p474

**移动赋值运算符**

能正确处理自赋值

**移后源对象必须可析构**

移动完 有时候源对象会销毁（有时候不会） 也就是说会在源对象上调用析构函数

在移动操作之后 移后源对象必须保持有效的、可析构的状态 但是用户不能对其值进行任何假设

**合成的移动操作**

当有三个拷贝控制成员时 不会合成这两个

只有一个类没有定义任何自己版本的拷贝控制成员时

且类的每个非静态数据成员都可移动时

编译器才会为它合成这两个

与拷贝操作不同 移动操作永远不会隐式定义为删除的函数

但 如果我们显式地要求编译器生成=default的移动操作

且编译器不能移动所有成员 则编译器会将移动操作定义为删除的函数

还有最重要的 什么时候将合成的移动操作定义为删除的函数遵循的和合成拷贝操作类似



1 与拷贝构造函数不同 被定义为删除的函数条件：有类成员定义了自己的拷贝构造函数且为定义移动 或有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数运算符类似

2 如果类的移动构造或移动运算符被定义为删除的或是不可访问的 则类的移动构造函数或移动运算符被定义为删除的

3 类似拷贝构造函数 类的析构函数被定义为删除的或不可访问的则类的移动构造函数被定义为删除的

4 类似拷贝赋值运算符 如果有类的成员是const或引用 则类的移动赋值运算符被定义为删除的

最后：如果类定义了一个移动构造函数或移动赋值运算符

则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的

也就是说：定义了一个移动。。成员的类必须也定义自己的拷贝操作，否则拷贝成员会被默认为删除的

**移动右值，拷贝左值。。。。。。**

如果一个类既有移动构造函数 又有拷贝构造函数 照常函数匹配

**。。。。。。但如果没有移动构造函数，右值也被拷贝**

就是没有移动构造函数 就用拷贝构造函数

拷贝构造函数能很好的替代移动构造函数

为什么要有移动构造函数 还是减少消耗的问题

**拷贝并交换赋值运算符和移动操作**

添加了拷贝并交换赋值运算符

它是函数匹配和移动操作间相互关系的一个很好的示例

如果再添加一个移动构造函数 它实际上也会获得一个移动赋值运算符

因为拷贝并交换赋值运算符的参数是非引用 那么参数要进行拷贝

 那么传进来的参数左值拷贝 右值移动

因此单一的运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能

更新 ： 三/五法则 五个拷贝控制成员应该看成一个整体

定义了任何一个拷贝操作 它就应该定义所有五个操作

**Message类的移动操作**

前面的message类加了移动操作

**移动迭代器**

新标准库中定义了一种 **移动迭代器** 适配器

一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器

一般来说 一个解引用运算符返回一个指向元素的左值

但移动迭代器解引用返回一个右值引用

我们通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器

接受一个迭代器参数 返回一个移动迭代器

原迭代器的所有其他操作都可以用



值得注意 标准库不保证哪些算法使用移动迭代器 哪些不适用

由于移动一个对象可能销毁原对象 因此只有在确信算法进行后不再访问该元素 才用移动迭代器

### 右值引用和成员函数

成员函数常见的两个版本

const X&

X&&

通常没有const X&&和普通的X

**右值和左值引用成员函数**

我们在右值上也可调用成员函数

指出this的左值右值属性与定义const成员函数相同

在参数列表后放一个 **引用限定符**

加一个&或&&

指出this可以指向一个左值或右值

类似const限定符

引用限定符只能用于非静态成员函数

且必须同时出现在函数的声明和定义中

一个函数可以同时用const和引用限定 在此情况下引用限定符必须跟随在const限定符之后

**重载和引用函数**

就像一个成员函数可以根据是否有const来区分其重载版本一样

引用限定符也可以区分重载版本

当我们仅定义const成员函数时 可以定义两个版本

唯一的差别是一个版本有const

而另一个没有

引用限定的函数则不一样 如果定义了两个或以上的同名同参函数 就必须对所有函数都加上引用限定符 或者所有都不加



如果一个成员函数有引用限定符 则具有相同参数的列表的所有版本都必须有引用限定符
