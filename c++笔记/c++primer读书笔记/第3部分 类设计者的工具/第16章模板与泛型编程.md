# 模板与泛型编程

## 定义模板

### 函数模板

一个函数模板就是一个公式

可用来生成针对特定类型的函数版本

模板定义以 关键字 template 开始

后跟一个模板参数列表

这是一个逗号分隔的一个或多个 **模板参数**列表

模板实参

**实例化函数模板**

当我们调用一个函数模板时

编译器根据函数实参来推断模板实参

用函数实参类型来绑定到模板参数的类型

有模板 就有对应的实例

**模板类型参数**

它可以用来指定返回类型 作为函数参数类型 用于变量声明 类型转换

类型参数前要加 typename 或者 class 两者一样

**非类型模板参数**

可以定义 **非类型参数**

是一个值

绑定到非类型整型参数的实参必须是一个常量表达式

绑定到指针或引用非类型参数的实参必须具有静态的生存期

模板非类型参数是一个常量值

在需要常量表达式的地方可以用

**inline 和 constexpr函数模板**

放在模板参数列表之后 返回类型之前

**编写类型无关的代码**

两个编写泛型代码的重要原则

1 模板中的函数参数时const的引用

2 函数体中的条件判断仅使用< 比较运算

保证了函数能用于不能拷贝的类型

且 用const引用运行更快

模板程序应该尽量减少对实参类型的要求

**模板编译**

当遇到模板定义 不生成代码

只有实例化才生成代码

函数模板和类模板成员函数的定义通常放在头文件中

**大多数编译错误在实例化期间报告**

### 类模板



**定义类模板**

**实例化类模板**

使用类模板要提供 **显式模板实参**列表、

**在模板作用域中引用模板类型**

**类模板的成员函数**

定义在类模板之外的成员函数就必须以关键字template

**类模板成员函数的实例化**

默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化

**在类代码内简化模板类名的使用**

在类模板自己的作用域中，我们可以直接使用模板名而不提实参

在一个类模板的作用域中 编译器处理模板自身引用时无需再写上模板参数

**在类模板外使用类模板名**

返回类型位于作用域之外

在一个类模板的作用域内 我们可以直接使用模板名而不必指定模板实参

**类模板和友元**

**一对一友好关系**

特定实例 对应特定实例

先要声明模板自身

**通用和特定的模板友好关系**

p589

**令模板自己的类型参数成为友元**

