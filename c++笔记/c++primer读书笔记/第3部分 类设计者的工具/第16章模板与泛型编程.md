# 

## 定义模板

### 函数模板

一个函数模板就是一个公式

可用来生成针对特定类型的函数版本

模板定义以 关键字 template 开始

后跟一个模板参数列表

这是一个逗号分隔的一个或多个 **模板参数**列表

模板实参

**实例化函数模板**

当我们调用一个函数模板时

编译器根据函数实参来推断模板实参

用函数实参类型来绑定到模板参数的类型

有模板 就有对应的实例

**模板类型参数**

它可以用来指定返回类型 作为函数参数类型 用于变量声明 类型转换

类型参数前要加 typename 或者 class 两者一样

**非类型模板参数**

可以定义 **非类型参数**

是一个值

绑定到非类型整型参数的实参必须是一个常量表达式

绑定到指针或引用非类型参数的实参必须具有静态的生存期

模板非类型参数是一个常量值

在需要常量表达式的地方可以用

**inline 和 constexpr函数模板**

放在模板参数列表之后 返回类型之前

**编写类型无关的代码**

两个编写泛型代码的重要原则

1 模板中的函数参数时const的引用

2 函数体中的条件判断仅使用< 比较运算

保证了函数能用于不能拷贝的类型

且 用const引用运行更快

模板程序应该尽量减少对实参类型的要求

**模板编译**

当遇到模板定义 不生成代码

只有实例化才生成代码

函数模板和类模板成员函数的定义通常放在头文件中

**大多数编译错误在实例化期间报告**

### 类模板



**定义类模板**

**实例化类模板**

使用类模板要提供 **显式模板实参**列表、

**在模板作用域中引用模板类型**

**类模板的成员函数**

定义在类模板之外的成员函数就必须以关键字template

**类模板成员函数的实例化**

默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化

**在类代码内简化模板类名的使用**

在类模板自己的作用域中，我们可以直接使用模板名而不提实参

在一个类模板的作用域中 编译器处理模板自身引用时无需再写上模板参数

**在类模板外使用类模板名**

返回类型位于作用域之外

在一个类模板的作用域内 我们可以直接使用模板名而不必指定模板实参

**类模板和友元**

**一对一友好关系**

特定实例 对应特定实例

先要声明模板自身

**通用和特定的模板友好关系**

p589

**令模板自己的类型参数成为友元**

**模板类型别名**

是一族类的别名

**类模板的static成员**

### 模板参数

可用任何名字

**模板参数与作用域**

在模板内不能重用模板名

一个模板参数名在一个特定模板参数列表中只能出现一次

**模板声明**

一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置 出现于任何使用这些模板的代码之前

**使用类的类型成员**

假定作用域运算符访问的名字不是类型

要使用一个模板类型参数的类型成员 要显式地告诉 其是一个类型

要加上typename关键字

**默认模板实参**

可以为函数和类模板提供默认实参

**模板默认实参与类模板**

### 成员模板

成员模板不能是虚函数

**普通（非模板）类的成员模板**

自定义unique删除器

**类模板的成员模板**

在类外面定义成员模板（函数）时

两个模板参数都要写

**实例化与成员模板**

成员模板的应用

### 控制实例化

每次使用相同的实例 在多个文件下

开销可能很严重

我们可以 **显式实例化**

**实例化extern声明**不会生成代码

可以有多个显式声明 必须只有一个定义

用了显式实例化 只要实例化一次就能在其他文件中出现代码了

对每个实例化声明 在程序中某个位置必须有其显式的实例化定义

**实例化定义会实例化所有成员**

在一个类模板的实例化定义中，所有类型必须能用于模板的所有成员函数

### 效率与灵活性

例如 shared 和unique 它们的不同体现在如何处理重载删除器上

可能对性能有重要影响

**在运行时绑定删除器**

比如shared

可以随时改变删除器的类型

**在编译时绑定删除器**

比如unique

无运行时额外开销

16.1.6 实现自己版本的智能指针

## 模板实参推断

### 类型转换与模板类型参数

将实参传递给带模板类型的函数形参时 能够自动应用的类型转换只有const

转换 及数组或函数到指针的转换

**使用相同模板参数类型的函数形参**

因为有限的转换

我们得用不同的形参

然后在函数体内发生类型转换

**正常类型转换应用于普通函数实参**

### 函数模板显式实参

当函数返回类型与参数列表中任何类型都不相同时

编译器可能无法推断 或者我们希望用户控制模板实例化

**指定显式模板实参**

是显式尖括号指定返回类型

从左到右依次匹配 参数与实参

**正常类型转换应用于显式指定的实参**

### 尾置返回类型与类型转换

用于在编写模板函数显式的指定返回类型

**进行类型转换的标准库模板类**

去引用类型

### 函数指针和实参推断

当参数是一个函数模板实例的地址时 也就是函数指针

程序上下文必须满足 对每个模板参数能唯一确定其类型或值 无歧义

### 模板实参推断和引用

**从左值引用函数参数推断类型**

模板中加不加const很关键

它影响到T的类型的推断

**从右值引用函数参数推断类型**

**引用折叠和右值引用**

间接创建的引用的引用会折叠

引用折叠只能用于上述

如类型别名或模板函数

p609 介绍了两个例外

由此生出两个规则

1 如果一个函数参数时一个指向模板类型参数的右值引用 则它可以被绑定到一个左值 且

2 如果实参是一个左值 会判定推断为左值引用 且函数参数将被实例化为一个普通的左值引用参数

**编写接受右值引用参数的模板函数**

### 理解std::move

p610

**从一个左值static_cast到一个右值引用是允许的**

### 转发

**定义能保持类型信息的函数参数**

如果一个函数参数是指向模板类型参数的右值引用 那么它对应的实参的const属性和 左右值属性将得到保持

**在调用中使用std::forward保持类型信息**

当用于一个指向模板参数类型的右值引用函数

forward会保持实参类型的所有细节

## 重载与模板

**编写重载模板**

**多个可行模板**

当有多个重载模板对一个调用提供同样好的匹配时 应选择最特例化的版本

**非模板和模板重载**

对于一个调用 如果一个非函数模板与一个函数模板提供同样好的匹配 则选择非模板版本

**重载模板和类型转换**

**缺少声明可能导致程序行为异常**

### 可变参数模板

**sizeof...运算符**

**编写可变参数函数模板**

### 包扩展

**理解包扩展**

扩展中的模式会独立地应用于包中的每个元素

#### 转发参数包

## 模板特例化

**定义函数模板特例化**

特例化的本质是实例化的一个模板

而非重载它 因此 特例化不影响函数匹配

****

**类模板特例化**

**类模板部分特例化**

我们只能部分特例化类模板

而不能部分特例化函数模板

**特例化成员不是类**

