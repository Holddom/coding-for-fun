# 模板与泛型编程

## 定义模板

### 函数模板

一个函数模板就是一个公式

可用来生成针对特定类型的函数版本

模板定义以 关键字 template 开始

后跟一个模板参数列表

这是一个逗号分隔的一个或多个 **模板参数**列表

模板实参

**实例化函数模板**

当我们调用一个函数模板时

编译器根据函数实参来推断模板实参

用函数实参类型来绑定到模板参数的类型

有模板 就有对应的实例

**模板类型参数**

它可以用来指定返回类型 作为函数参数类型 用于变量声明 类型转换

类型参数前要加 typename 或者 class 两者一样

**非类型模板参数**

可以定义 **非类型参数**

是一个值

绑定到非类型整型参数的实参必须是一个常量表达式

绑定到指针或引用非类型参数的实参必须具有静态的生存期

模板非类型参数是一个常量值

在需要常量表达式的地方可以用

**inline 和 constexpr函数模板**

放在模板参数列表之后 返回类型之前

**编写类型无关的代码**

两个编写泛型代码的重要原则

1 模板中的函数参数时const的引用

2 函数体中的条件判断仅使用< 比较运算

保证了函数能用于不能拷贝的类型

且 用const引用运行更快

模板程序应该尽量减少对实参类型的要求

**模板编译**

当遇到模板定义 不生成代码

只有实例化才生成代码

函数模板和类模板成员函数的定义通常放在头文件中

**大多数编译错误在实例化期间报告**

### 类模板



**定义类模板**

**实例化类模板**

使用类模板要提供 **显式模板实参**列表、

**在模板作用域中引用模板类型**

**类模板的成员函数**

定义在类模板之外的成员函数就必须以关键字template

**类模板成员函数的实例化**

默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化

**在类代码内简化模板类名的使用**

在类模板自己的作用域中，我们可以直接使用模板名而不提实参

在一个类模板的作用域中 编译器处理模板自身引用时无需再写上模板参数

**在类模板外使用类模板名**

返回类型位于作用域之外

在一个类模板的作用域内 我们可以直接使用模板名而不必指定模板实参

**类模板和友元**

**一对一友好关系**

特定实例 对应特定实例

先要声明模板自身

**通用和特定的模板友好关系**

p589

**令模板自己的类型参数成为友元**

**模板类型别名**

是一族类的别名

**类模板的static成员**

### 模板参数

可用任何名字

**模板参数与作用域**

在模板内不能重用模板名

一个模板参数名在一个特定模板参数列表中只能出现一次

**模板声明**

一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置 出现于任何使用这些模板的代码之前

**使用类的类型成员**

假定作用域运算符访问的名字不是类型

要使用一个模板类型参数的类型成员 要显式地告诉 其是一个类型

要加上typename关键字

**默认模板实参**

可以为函数和类模板提供默认实参

**模板默认实参与类模板**

### 成员模板

成员模板不能是虚函数

**普通（非模板）类的成员模板**

自定义unique删除器

**类模板的成员模板**

在类外面定义成员模板（函数）时

两个模板参数都要写

**实例化与成员模板**

成员模板的应用

### 控制实例化

每次使用相同的实例 在多个文件下

开销可能很严重

我们可以 **显式实例化**

**实例化extern声明**不会生成代码

可以有多个显式声明 必须只有一个定义

用了显式实例化 只要实例化一次就能在其他文件中出现代码了

对每个实例化声明 在程序中某个位置必须有其显式的实例化定义

**实例化定义会实例化所有成员**

在一个类模板的实例化定义中，所有类型必须能用于模板的所有成员函数

### 效率与灵活性

例如 shared 和unique 它们的不同体现在如何处理重载删除器上

可能对性能有重要影响

**在运行时绑定删除器**

比如shared

可以随时改变删除器的类型

**在编译时绑定删除器**

比如unique

无运行时额外开销

16.1.6 实现自己版本的智能指针

## 模板实参推断

### 类型转换与模板类型参数

将实参传递给带模板类型的函数形参时 能够自动应用的类型转换只有const

转换 及数组或函数到指针的转换

**使用相同模板参数类型的函数形参**

因为有限的转换

我们得用不同的形参

然后在函数体内发生类型转换

**正常类型转换应用于普通函数实参**

### 函数模板显式实参

当函数返回类型与参数列表中任何类型都不相同时

编译器可能无法推断 或者我们希望用户控制模板实例化

**指定显式模板实参**

是显式尖括号指定返回类型

从左到右依次匹配 参数与实参

**正常类型转换应用于显式指定的实参**

