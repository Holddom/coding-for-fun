# 面向对象程序设计

基于三个基本概念：数据抽象 继承和动态绑定

## OOP：概述

**面向对象程序设计**的核心思想是数据抽象、继承和动态绑定

**继承**

通过继承联系在一起的类构成一种层次关系

通常在层次关系的根部有一个 **基类**

其他的类则直接或间接地从基类继承而来

称为 **派生类**

在cpp中 基类将类型相关的函数与派生类不做改变直接继承的函数区分对待

对于某些函数 基类希望派生类各自定义合适的版本 此时基类就将这些函数声明成

**虚函数**	派生类必须通过使用 **类派生列表**明确指出它是从哪个（些）继承而来的

**动态绑定**

通过动态绑定 我们能用同一段代码分别处理基类和派生类的对象

函数运行的版本由实参决定 既在运行时选择函数的版本 动态绑定又被称为 **运行时绑定**

在cpp中 当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定

### 定义基类和派生类

#### 定义基类

首先 作为基类 通常都应该定义一个虚析构函数 即使该函数不执行任何实际操作也是如此

**成员函数与继承**

有些函数与类型相关 派生类必须对其重新定义以 **覆盖override**从基类继承来的旧定义

我们通常把它定义为 **虚函数**

当我们使用指针或引用调用虚函数时 将进行动态绑定 根据对象的类型不同 执行的函数版本也不同

关键字 virtual 使该函数进行动态绑定 任何构造函数之外的非静态函数都可以是虚函数

这个关键字只能出现在类内部的声明中

**访问控制与继承**

派生类可以继承基类中的成员 但派生类的成员函数不一定能访问从基类继承来的成员

派生类能访问公有成员 而不能访问私有成员 

有 **protected** 基类希望它的派生类有权访问此类成员 同时禁止其他成员访问

我们用 **受保护的**访问运算符说明这样的成员

#### 定义派生类

通过使用 **类派生列表**明确指出它是从哪个基类继承而来的

**派生类中的虚函数**

如果派生类没有覆盖其基类中的某个虚函数 则派生类会直接继承其在基类中的版本

**派生类对象及派生类向基类的类型转换**

派生类对象中含有与其基类对应的组成部分 所以我们能把派生类的对象当成基类对象来使用

也能将基类的指针和引用绑定到派生类对象中的基类部分上

这种转换通常称为 **派生类到基类的类型转换**

在派生类对象中含有与其基类对应的组成部分 这一事实是继承的关键所在

**派生类构造函数**

派生类必须使用基类的构造函数来初始化它的基类部分

每个类控制它自己的成员初始化过程

派生类构造函数通过构造函数初始化列表来将实参传递给基类的构造函数

首先初始化基类的部分 然后按照声明的顺序依次初始化派生类的成员

**派生类使用基类的成员**

派生类可以访问基类的公有成员和受保护成员

派生类的作用域嵌套在基类的作用域内

**继承与静态成员**

如果基类定义了一个静态成员 则在整个继承体系中值存在该成员的唯一定义

静态成员遵循通用的访问控制规则 如果其可访问 我们即能从基类访问也能从派生类访问

**派生类的声明**

就和其他类一样正常声明 派生列表不出现

**被用作基类的类**

此类一定是被定义的

隐含了 一个类不能派生它自身

一个类可以同时是基类和派生类

有直接基类和间接基类

一个最终的派生类会包含这些基类的子对象

**防止继承的发生**

不想让类作为基类

在类名后加上 **final**	可以防止继承的发生

#### 类型转换与继承

理解基类和派生类之间的类型转换是理解cpp面向对象编程的关键所在

可以将基类的指针或引用绑定到一个对象 可能是基类 可能是派生类

智能指针也支持

**静态类型与动态类型**

表达式的静态类型在编译时就已知 它是一个变量声明的类型或表达式生成的类型

动态类型则是变量或表达式表示的内存中的对象的类型 动态类型直到运行时才可知

跟动态绑定有关

如果表达式既不是引用也不是指针 则它的动态类型永远与静态类型一致

基类的指针或引用的静态类型可能与其动态类型不一致 ！！！

**不存在从基类向派生类的隐式类型转换**

一个基类的对象可能是派生类的一部分 也可能不是 所以不存在从基类向派生类的自动类型转换也就是说不能将基类转换成派生类 （反之成立）

还有就是 即使我们先用基类的指针或引用绑定了一个派生类对象

我们还是不能再用一个派生类的指针或引用去绑定这个指针或引用

还是不能执行从基类向派生类的转换

编译器无法在编译时确定某个特定的转换在运行时是否安全

编译器只能通过检查指针或引用的静态类型来推断转换是否合法

如果基类中含有一个或多个虚函数 可以用动态转换请求类型转换

如果确定了某个基类向派生类的转换是安全的 则我们可以用静态转换在编译时强制覆盖

编译器的检查工作

**在对象之间不存在类型转化**

自动类型转化只在指针或引用类型有效

在派生类型和基类类型之间不存在这样的转换

我们想让派生类对象转换成它的基类类型 可能转换后与期望有差别

当初始化或赋值一个类的对象 实际上是在调用某个函数

因为学到的 这些函数接受一个const引用 所以派生类向基类的转换允许我们给基类的拷贝 移动操作传递一个派生类对象

这些函数是基类的 只能处理基类自己的成员

当我们用一个派生类对象为一个基类对象初始化或赋值时 只有该派生类对象中的基类部分会被拷贝 移动或赋值 它的派生类部分将被忽略掉





### 虚函数

