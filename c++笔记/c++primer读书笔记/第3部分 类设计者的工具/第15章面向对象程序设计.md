# 面向对象程序设计

基于三个基本概念：数据抽象 继承和动态绑定

## OOP：概述

**面向对象程序设计**的核心思想是数据抽象、继承和动态绑定

**继承**

通过继承联系在一起的类构成一种层次关系

通常在层次关系的根部有一个 **基类**

其他的类则直接或间接地从基类继承而来

称为 **派生类**

在cpp中 基类将类型相关的函数与派生类不做改变直接继承的函数区分对待

对于某些函数 基类希望派生类各自定义合适的版本 此时基类就将这些函数声明成

**虚函数**	派生类必须通过使用 **类派生列表**明确指出它是从哪个（些）继承而来的

**动态绑定**

通过动态绑定 我们能用同一段代码分别处理基类和派生类的对象

函数运行的版本由实参决定 既在运行时选择函数的版本 动态绑定又被称为 **运行时绑定**

在cpp中 当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定

### 定义基类和派生类

#### 定义基类

首先 作为基类 通常都应该定义一个虚析构函数 即使该函数不执行任何实际操作也是如此

**成员函数与继承**

有些函数与类型相关 派生类必须对其重新定义以 **覆盖override**从基类继承来的旧定义

我们通常把它定义为 **虚函数**

当我们使用指针或引用调用虚函数时 将进行动态绑定 根据对象的类型不同 执行的函数版本也不同

关键字 virtual 使该函数进行动态绑定 任何构造函数之外的非静态函数都可以是虚函数

这个关键字只能出现在类内部的声明中

**访问控制与继承**

派生类可以继承基类中的成员 但派生类的成员函数不一定能访问从基类继承来的成员

派生类能访问公有成员 而不能访问私有成员 

有 **protected** 基类希望它的派生类有权访问此类成员 同时禁止其他成员访问

我们用 **受保护的**访问运算符说明这样的成员

#### 定义派生类

通过使用 **类派生列表**明确指出它是从哪个基类继承而来的

**派生类中的虚函数**

如果派生类没有覆盖其基类中的某个虚函数 则派生类会直接继承其在基类中的版本

**派生类对象及派生类向基类的类型转换**

派生类对象中含有与其基类对应的组成部分 所以我们能把派生类的对象当成基类对象来使用

也能将基类的指针和引用绑定到派生类对象中的基类部分上

这种转换通常称为 **派生类到基类的类型转换**

在派生类对象中含有与其基类对应的组成部分 这一事实是继承的关键所在

**派生类构造函数**

派生类必须使用基类的构造函数来初始化它的基类部分

每个类控制它自己的成员初始化过程

派生类构造函数通过构造函数初始化列表来将实参传递给基类的构造函数

首先初始化基类的部分 然后按照声明的顺序依次初始化派生类的成员

**派生类使用基类的成员**

派生类可以访问基类的公有成员和受保护成员

派生类的作用域嵌套在基类的作用域内

**继承与静态成员**

如果基类定义了一个静态成员 则在整个继承体系中值存在该成员的唯一定义

静态成员遵循通用的访问控制规则 如果其可访问 我们即能从基类访问也能从派生类访问

**派生类的声明**

就和其他类一样正常声明 派生列表不出现

**被用作基类的类**

此类一定是被定义的

隐含了 一个类不能派生它自身

一个类可以同时是基类和派生类

有直接基类和间接基类

一个最终的派生类会包含这些基类的子对象

**防止继承的发生**

不想让类作为基类

在类名后加上 **final**	可以防止继承的发生

#### 类型转换与继承

理解基类和派生类之间的类型转换是理解cpp面向对象编程的关键所在

可以将基类的指针或引用绑定到一个对象 可能是基类 可能是派生类

智能指针也支持

**静态类型与动态类型**

表达式的静态类型在编译时就已知 它是一个变量声明的类型或表达式生成的类型

动态类型则是变量或表达式表示的内存中的对象的类型 动态类型直到运行时才可知

跟动态绑定有关

如果表达式既不是引用也不是指针 则它的动态类型永远与静态类型一致

基类的指针或引用的静态类型可能与其动态类型不一致 ！！！

**不存在从基类向派生类的隐式类型转换**

一个基类的对象可能是派生类的一部分 也可能不是 所以不存在从基类向派生类的自动类型转换也就是说不能将基类转换成派生类 （反之成立）

还有就是 即使我们先用基类的指针或引用绑定了一个派生类对象

我们还是不能再用一个派生类的指针或引用去绑定这个指针或引用

还是不能执行从基类向派生类的转换

编译器无法在编译时确定某个特定的转换在运行时是否安全

编译器只能通过检查指针或引用的静态类型来推断转换是否合法

如果基类中含有一个或多个虚函数 可以用动态转换请求类型转换

如果确定了某个基类向派生类的转换是安全的 则我们可以用静态转换在编译时强制覆盖

编译器的检查工作

**在对象之间不存在类型转化**

自动类型转化只在指针或引用类型有效

在派生类型和基类类型之间不存在这样的转换

我们想让派生类对象转换成它的基类类型 可能转换后与期望有差别

当初始化或赋值一个类的对象 实际上是在调用某个函数

因为学到的 这些函数接受一个const引用 所以派生类向基类的转换允许我们给基类的拷贝 移动操作传递一个派生类对象

这些函数是基类的 只能处理基类自己的成员

当我们用一个派生类对象为一个基类对象初始化或赋值时 只有该派生类对象中的基类部分会被拷贝 移动或赋值 它的派生类部分将被忽略掉





### 虚函数

直到运行时才直到到底运行了哪个版本的虚函数

**对虚函数的调用可能在运行时才被解析**

一直在强调指针或引用之于虚函数 只有在运行阶段才能确定版本



**c++的多态性**

oop的核心思想是多态性

我们把具有继承关系的多个类型称为多态

我们能统一地使用它们而不用在意它们的差异

引用或指针的静态类型与动态类型不同这一事实正是cpp语言支持多态性的根本存在

对非虚函数 我们用基类定义 也不知道到时会真正作用什么类型 但它是在编译时绑定的

（引用或指针）

对对象而言也在编译时绑定（无论是否为虚函数）



总结 当且仅当对通过指针或引用调用虚函数时

才会在运行时解析该调用

也只有在这种情况下 对象的动态类型才有可能与静态类型不同

**派生类中的虚函数**

当我们在派生类中覆盖了某个虚函数时 可以再一次使用virtual关键字指出该虚函数

的性质 非必须

一旦某个函数被声明称虚函数 则在所有派生类中它都是虚函数

派生类想覆盖虚函数 形参类型必须与被覆盖的基类函数完全一致

 返回类型也是

例外 当虚函数返回类型是类本身的指针或引用时 规则无效

**final和override说明符**

类似虚函数的重载问题 

函数名和虚函数相同 形参列表不同没问题 不是覆盖的 而是一个独立的函数

显示加 override表示这个是虚函数 得覆盖 如果没覆盖会报错

如果加个 final 则不能再覆盖他了

**虚函数与默认实参**

使用默认实参 调用由静态类型决定

如果虚函数使用默认实参 则基类和派生类中定义的默认实参最好一致

**回避虚函数的机制**

如果有些时候 我们不希望对虚函数的调用不要进行动态绑定 而是强迫其执行虚函数的某个特定版本 

使用作用域运算符可以实现这一目的

强行调用

不管调用对象的实际动态类型是什么

该调用会在编译时完成解析

note：通常情况下 只有成员函数或友元函数 中的代码才需要使用作用域运算符来回避虚函数的机制

当一个派生类的虚函数调用它覆盖的基类的虚函数版本时

在此情况下 基类的版本通常完成继承层次中所有类型都要完成的共同任务

而派生类中定义的版本需要执行一些与派生类本身密切相关的操作



如果一个派生类虚函数需要调用它的基类版本

但是没有使用作用域运算符 则在运行时该调用将被解析为对派生类版本自身的调用

从而导致无限递归

### 抽象基类

与用户实际使用的类不同

提供概念上的一系列数据

不希望用户创建这样的对象

**纯虚函数**

有些函数在这种类失去了实际的意义

所以我们要把它定义为纯虚函数

纯虚函数无需定义 在函数体后 分号前 加一个=0 即可

**含有纯虚函数的类是抽象基类**

未覆盖直接继承的也是

抽象基类负责定义接口 其他类可以覆盖接口

*我们不能直接定义一个抽象基类的对象*

**派生类构造函数只初始化它的直接基类**



关键概念 重构

重构负责重新设计类的体系 

以便将操作和/或 数据从一个类 移动到另一个类当中

对于oop 这很普遍



### 访问控制和继承

**受保护的成员**

对于派生类的成员和友元来说是可访问的

派生类的成员或友元只能通过派生类对象来访问基类的受保护的成员（继承而来的）

派生类对于一个基类的对象中的受保护成员没有任何访问特权

总之 只能访问派生类中的基类部分的protected

**公有、私有和受保护继承**

访问权限 受两个因素影响

1 在基类的访问说明符

2 在派生类的派生列表中的访问说明符

派生列表中的访问说明符与能否访问直接基类的成员没什么影响

只是控制继承来的成员访问权限

还能控制继承自派生类的新类的访问权限

**派生类向基类转换的可访问性**

1 当D公有的继承B D才可以向B转换 （用户代码）

2 无论D什么方式继承 D的成员函数和友元 都能使用D-》B的转换

3 如果D继承B 是public 或 protected 的  则D的派生类E的成员和友元可以用D->B的转换



tip 对于代码中的某个给定节点来说 如果基类的公有成员是可访问的 则派生类向基类的类型转换

则派生类向基类的类型转换也是可访问的 反之不行

**友元与继承**

友元不能传递和继承

对基类的访问权限由基类本身控制 

也就是说基类的友元能访问基类的成员 而且还能访问派生类中继承来的基类部分的成员

**改变个别成员的可访问性**

有时需要改变派生类继承的某个名字的访问级别

通过使用using

可以将类的直接或间接基类中可访问的非私有成员标记出来

派生类只能为那些它可以访问的名字提供using声明

**默认的继承保护级别**

struct 默认访问说明符为public

class为private

！！！

**注意**

struct和class没有更深层次的差别 

唯一的差别就是默认成员访问说明符及默认派生访问说明符

除此之外 再无其他不同之处

### 继承中的类作用域

派生类的作用域嵌套在其基类的作用域之内

解析名字的时候由内到外

**在编译时进行名字查找**

我们能使用哪些成员是由静态类型决定的

比如 A->B->C

B中的一个公开成员函数

C当然可以访问

但C被绑定到A的指针上

这个指针不能访问这个成员函数

**名字冲突与继承**

一样

内层隐藏外层的

派生类的成员将隐藏同名的基类成员

**通过作用域运算符来使用隐藏的成员**

除了覆盖继承而来的虚函数之外 派生类最好不要重用其他定义在基类中的名字

关键概念 ： 讲了名字查找的过程

**一如往常，名字查找先于类型检查**

声明在内层作用域的函数不会重载声明在外层作用域的函数

派生类如果想用基类的同名函数要加上作用域运算符

**虚函数与作用域**

上面其实也就解释了 为什么虚函数必须要有相同的形参列表了

如果不一样 则基类的函数被隐藏

**通过基类调用隐藏的虚函数**

p551

注意 非虚函数的调用不会发生动态绑定

**覆盖重载的函数**

成员函数无论是否虚函数都能被重载

派生类可以选择覆盖重载虚函数

如果所有重载版本都对派生类可见 必须都覆盖或都不覆盖

麻烦

使用using+函数名将重载函数们加到派生类作用域中

此时派生类只需定义其特有的函数就行了

无需为继承而来的其他。。。重新定义

### 构造函数与拷贝控制

#### 虚析构函数

当使用delete时执行析构函数

指针的静态类型与静态类型不符的情况 需要将析构函数定义为虚函数



如果基类的析构函数不是虚函数 则delete一个指向派生类对象的基类指针将产生未定义的行为

由前面的三五法则 一个类需要析构函数 则它也需要拷贝和赋值操作

但基类的析构函数是个意外

一个基类总是需要析构函数

它可以是虚函数且内容为空

**虚析构函数将阻止合成移动操作**

基类需要一个虚析构函数

定义基类和派生类 它们定义析构函数 即使是=default

编译器也不会为这个类定义合成移动操作

#### 合成拷贝控制与继承

就是派生类的一些拷贝控制成员操作也在使用直接基类中对应的操作

只要求这些成员能被访问 不是删除的就行了

**派生类中删除的拷贝控制与基类的关系**

某些定义基类的方式也可能导致有的派生类成员成为被删除的函数

1 如果基类中的默认构造函数 拷贝构造函数 拷贝赋值运算符或析构函数是被删除的函数

或者不可访问 则派生类中对应的成员将是被删除的

原因是编译器不能使用基类成员来执行派生类对象基类部分的构造 赋值或销毁操作

2 如果基类中有一个不可访问或删除掉的析构函数 则派生类中合成的默认和拷贝构造函数将是被删除的

因为编译器无法销毁派生类对象的基类部分

3 和过去一样 编译器将不会合成一个删除掉的移动操作。

当我们用=default请求一个移动操作时

如果基类中的对应操作时删除的或不可访问的 那么派生类中该函数将是被删除的

原因是派生类对象的基类部分不可移动 同样如果基类的析构函数是删除的或不可访问的

则派生类的移动构造函数也将是被删除的

**移动操作与继承**

大多数基类都会定义一个虚析构函数 在此情况下

基类通常不含有合成的移动操作 而且在它的派生类中也没有

因为基类雀食移动操作会阻止派生类拥有自己的合成移动操作

所有当我们需要执行移动操作时 应该首先在基类中进行定义

#### 派生类的拷贝控制成员

构造函数 和赋值运算符 不仅为派生类自己的负责还要为基类部分的负责

但析构函数不同 只负责销毁派生类自己的资源

当派生类定义了拷贝或移动操作时 该操作负责拷贝或移动包括基类部分成员在内的整个对象

**定义派生类的拷贝或移动构造函数**

当为派生类定义拷贝或构造函数时

我们通常使用对应的基类构造函数初始化对象的基类部分

默认情况 基类的默认构造函数初始化对象的基类部分

想使用拷贝或移动构造函数 要在初始化列表中显式使用

**派生类赋值运算符**

与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类赋值

无论是自己定义的 还是 合成的（构造函数 赋值运算符）

派生类都能使用 一定要显式

**派生类析构函数**

