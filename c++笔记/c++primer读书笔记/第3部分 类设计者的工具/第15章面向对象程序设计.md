# 面向对象程序设计

基于三个基本概念：数据抽象 继承和动态绑定

## OOP：概述

**面向对象程序设计**的核心思想是数据抽象、继承和动态绑定

**继承**

通过继承联系在一起的类构成一种层次关系

通常在层次关系的根部有一个 **基类**

其他的类则直接或间接地从基类继承而来

称为 **派生类**

在cpp中 基类将类型相关的函数与派生类不做改变直接继承的函数区分对待

对于某些函数 基类希望派生类各自定义合适的版本 此时基类就将这些函数声明成

**虚函数**	派生类必须通过使用 **类派生列表**明确指出它是从哪个（些）继承而来的

**动态绑定**

通过动态绑定 我们能用同一段代码分别处理基类和派生类的对象

函数运行的版本由实参决定 既在运行时选择函数的版本 动态绑定又被称为 **运行时绑定**

在cpp中 当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定

### 定义基类和派生类

#### 定义基类

首先 作为基类 通常都应该定义一个虚析构函数 即使该函数不执行任何实际操作也是如此

**成员函数与继承**

有些函数与类型相关 派生类必须对其重新定义以 **覆盖override**从基类继承来的旧定义

我们通常把它定义为 **虚函数**

当我们使用指针或引用调用虚函数时 将进行动态绑定 根据对象的类型不同 执行的函数版本也不同

关键字 virtual 使该函数进行动态绑定 任何构造函数之外的非静态函数都可以是虚函数

这个关键字只能出现在类内部的声明中

**访问控制与继承**

派生类可以继承基类中的成员 但派生类的成员函数不一定能访问从基类继承来的成员

派生类能访问公有成员 而不能访问私有成员 

有 **protected** 基类希望它的派生类有权访问此类成员 同时禁止其他成员访问

我们用 **受保护的**访问运算符说明这样的成员

#### 定义派生类

通过使用 **类派生列表**明确指出它是从哪个基类继承而来的

**派生类中的虚函数**

如果派生类没有覆盖其基类中的某个虚函数 则派生类会直接继承其在基类中的版本

**派生类对象及派生类向基类的类型转换**

派生类对象中含有与其基类对应的组成部分 所以我们能把派生类的对象当成基类对象来使用

也能将基类的指针和引用绑定到派生类对象中的基类部分上

这种转换通常称为 **派生类到基类的类型转换**

在派生类对象中含有与其基类对应的组成部分 这一事实是继承的关键所在

**派生类构造函数**

派生类必须使用基类的构造函数来初始化它的基类部分

每个类控制它自己的成员初始化过程

派生类构造函数通过构造函数初始化列表来将实参传递给基类的构造函数

首先初始化基类的部分 然后按照声明的顺序依次初始化派生类的成员

**派生类使用基类的成员**

派生类可以访问基类的公有成员和受保护成员

派生类的作用域嵌套在基类的作用域内

**继承与静态成员**

如果基类定义了一个静态成员 则在整个继承体系中值存在该成员的唯一定义

静态成员遵循通用的访问控制规则 如果其可访问 我们即能从基类访问也能从派生类访问

**派生类的声明**

就和其他类一样正常声明 派生列表不出现

**被用作基类的类**

此类一定是被定义的

隐含了 一个类不能派生它自身

一个类可以同时是基类和派生类

有直接基类和间接基类

一个最终的派生类会包含这些基类的子对象

**防止继承的发生**

不想让类作为基类

在类名后加上 **final**	可以防止继承的发生

#### 类型转换与继承

理解基类和派生类之间的类型转换是理解cpp面向对象编程的关键所在

可以将基类的指针或引用绑定到一个对象 可能是基类 可能是派生类

智能指针也支持

**静态类型与动态类型**

表达式的静态类型在编译时就已知 它是一个变量声明的类型或表达式生成的类型

动态类型则是变量或表达式表示的内存中的对象的类型 动态类型直到运行时才可知

跟动态绑定有关

如果表达式既不是引用也不是指针 则它的动态类型永远与静态类型一致

基类的指针或引用的静态类型可能与其动态类型不一致 ！！！

**不存在从基类向派生类的隐式类型转换**

一个基类的对象可能是派生类的一部分 也可能不是 所以不存在从基类向派生类的自动类型转换也就是说不能将基类转换成派生类 （反之成立）

还有就是 即使我们先用基类的指针或引用绑定了一个派生类对象

我们还是不能再用一个派生类的指针或引用去绑定这个指针或引用

还是不能执行从基类向派生类的转换

编译器无法在编译时确定某个特定的转换在运行时是否安全

编译器只能通过检查指针或引用的静态类型来推断转换是否合法

如果基类中含有一个或多个虚函数 可以用动态转换请求类型转换

如果确定了某个基类向派生类的转换是安全的 则我们可以用静态转换在编译时强制覆盖

编译器的检查工作

**在对象之间不存在类型转化**

自动类型转化只在指针或引用类型有效

在派生类型和基类类型之间不存在这样的转换

我们想让派生类对象转换成它的基类类型 可能转换后与期望有差别

当初始化或赋值一个类的对象 实际上是在调用某个函数

因为学到的 这些函数接受一个const引用 所以派生类向基类的转换允许我们给基类的拷贝 移动操作传递一个派生类对象

这些函数是基类的 只能处理基类自己的成员

当我们用一个派生类对象为一个基类对象初始化或赋值时 只有该派生类对象中的基类部分会被拷贝 移动或赋值 它的派生类部分将被忽略掉





### 虚函数

直到运行时才直到到底运行了哪个版本的虚函数

**对虚函数的调用可能在运行时才被解析**

一直在强调指针或引用之于虚函数 只有在运行阶段才能确定版本



**c++的多态性**

oop的核心思想是多态性

我们把具有继承关系的多个类型称为多态

我们能统一地使用它们而不用在意它们的差异

引用或指针的静态类型与动态类型不同这一事实正是cpp语言支持多态性的根本存在

对非虚函数 我们用基类定义 也不知道到时会真正作用什么类型 但它是在编译时绑定的

（引用或指针）

对对象而言也在编译时绑定（无论是否为虚函数）



总结 当且仅当对通过指针或引用调用虚函数时

才会在运行时解析该调用

也只有在这种情况下 对象的动态类型才有可能与静态类型不同

**派生类中的虚函数**

当我们在派生类中覆盖了某个虚函数时 可以再一次使用virtual关键字指出该虚函数

的性质 非必须

一旦某个函数被声明称虚函数 则在所有派生类中它都是虚函数

派生类想覆盖虚函数 形参类型必须与被覆盖的基类函数完全一致

 返回类型也是

例外 当虚函数返回类型是类本身的指针或引用时 规则无效

**final和override说明符**

类似虚函数的重载问题 

函数名和虚函数相同 形参列表不同没问题 不是覆盖的 而是一个独立的函数

显示加 override表示这个是虚函数 得覆盖 如果没覆盖会报错

如果加个 final 则不能再覆盖他了

**虚函数与默认实参**

使用默认实参 调用由静态类型决定

如果虚函数使用默认实参 则基类和派生类中定义的默认实参最好一致

**回避虚函数的机制**

如果有些时候 我们不希望对虚函数的调用不要进行动态绑定 而是强迫其执行虚函数的某个特定版本 

使用作用域运算符可以实现这一目的

强行调用

不管调用对象的实际动态类型是什么

该调用会在编译时完成解析

note：通常情况下 只有成员函数或友元函数 中的代码才需要使用作用域运算符来回避虚函数的机制

当一个派生类的虚函数调用它覆盖的基类的虚函数版本时

在此情况下 基类的版本通常完成继承层次中所有类型都要完成的共同任务

而派生类中定义的版本需要执行一些与派生类本身密切相关的操作



如果一个派生类虚函数需要调用它的基类版本

但是没有使用作用域运算符 则在运行时该调用将被解析为对派生类版本自身的调用

从而导致无限递归

### 抽象基类

