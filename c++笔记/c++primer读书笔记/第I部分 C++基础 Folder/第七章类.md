# **类**

## **基本思想**

### **数据抽象**

#### 依赖*接口*和*实现*分离的编程技术

### **封装**

实现了类的接口和实现的分离

封装后的类隐藏了它的实现细节

也就是说 类的用户只能使用接口而无法访问实现部分

**抽象数据类型ADT**

**定义成员函数**

*定义在类内部的函数是隐式的inline函数*

隐式参数`this`

`total.isbn()`

`isbn(&total)`//可以看作这样

当调用成员函数时

用请求该函数的对象地址初始化this

在成员函数内部

我们可以直接使用调用该函数的对象的成员

而无须通过成员访问运算符

任何对类成员的直接访问都被看作this的隐式引用

就是当isbn函数使用一个成员时 如`bookno`

如同 `this->bookno`

*`this`为常量指针*

**引入const成员函数**

`const`作用修改隐式this指针的类型

默认情况

`this`的类似是指向类类型非常量版本的常量指针

`类名 *const this`

即我们在默认情况下 不能把this绑定到一个常量对象上

在成员函数的参数列表 （）之后加上 `const`这样 this就成了指向常量的指针

提高了灵活性

这样使用const的成员函数 为 *常量成员函数*

常量对象 以及常量对象的引用或指针都只能调用常量成员函数

**类作用域和成员函数**

类本身就是一个作用域

即使成员变量定义在成员函数之后

成员函数还是能使用之后的成员变量

这是因为编译器先编译成员的声明 然后才轮到成员函数体

无需在意它们的次序

**在类的外部定义成员函数**

如果是常量成员函数别忘了const

属于类作用域

隐式使用了成员

**定义一个返回this对象的函数**

`return *this`

返回的是对象的引用 如果要求是左值的话

**定义类相关的非成员函数**

这些函数从概念上来说属于类的接口的组成部分

它们实际上并不属于类本身

如果函数概念上属于类 但不定义在类中 它一般应与类声明（而非定义）

在同一个头文件中 

`IO类`不能被拷贝 要用引用

读写会改变其内容 是普通引用

`read()`  `print()` 函数

**构造函数**

用来控制其对象的初始化方式

只要类的对象被创建 就会执行构造函数

*构造函数的名字和类名相同*

*没有返回类型*！！！

*可以有多个构造函数 类似重载函数*

*不能被声明成const  在构造函数完成初始化后 声明为const的对象才获得const属性*

**合成的默认构造函数**

类没有构造函数

没有为对象提供初始值

其实类通过一个特殊的构造函数来控制默认初始化过程

这个函数叫 **默认构造函数**

它无须任何实参

没有显式的定义构造函数

编译器会隐式的定义个默认构造函数

又被称为 **合成的默认构造函数**

按照如下规则初始化类的数据成员：

> 如果存在类内的初始值 则用它来初始化成员
>
> 否则 默认初始化该成员

**某些类不能依赖于合成的默认构造函数**

p236的三个原因

> 如果类包含有内置类型或者复合类型的成员 则只有当这些成员全都被赋予了
>
> 类内的初始值时 这个类才适合于使用合成的默认构造函数

~~~c++
struct Sales_data {
	Sales_data() = default;
	Sales_data(const std::string &s):bookNo(s){}
	Sales_data(const std::string &s, unsigned n, double p):
		bookNo(s),units_sold(n),revenue(p*n){}
	Sales_data(std::istream&);
	std::string isbn() const { return bookNo; }
	Sales_data combine(const Sales_data&);
	double avg_price() const;
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
~~~



**= default 的含义**

cpp11中 如果我们需要默认的行为 那么可以通过在参数列表后面写上

`= default`来要求编译器生成构造函数

它既可以和声明一起出现在类的内部 也可以作为定义出现在类的外部

如果已经有了一个自己给定的构造函数 那么这个构造函数时必须的（default）

注意函数的内联问题

**构造函数初始值列表**

~~~c++
Sales_data(const std::string &s):bookNo(s){}
	Sales_data(const std::string &s, unsigned n, double p):
		bookNo(s),units_sold(n),revenue(p*n){}
~~~

> 冒号以及冒号和花括号之间的代码

这就是 *构造函数初始值列表*

它负责为新创建的对象的一个或几个数据成员赋初值

它是成员名字的一个列表

每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值

不同成员的初始化通过逗号分割开来

对没有显式初始化的成员会与合成默认构造函数相同的方式隐式初始化

上面的两个构造函数中的函数体都是空的 这是因为这些构造函数的唯一目的就是为数据成员赋初值

**在类的外部定义的构造函数**

~~~c++
	Sales_data(std::istream&);
~~~

以输入流为参数的构造函数 需要执行一些实际的操作

在它的函数体内 调用了read函数以给数据成员赋初值

**构造函数没有返回类型**

**拷贝 赋值 析构**

类不定义这些功能 编译器会进行对对象的每个成员进行赋值 拷贝 销毁

**某些类不能依赖于合成的版本**

如构造体（类）中成员额外开辟的动态内存

当一个对象含有vector或者string成员 可以正常进行

**访问控制与封装**

**访问说明符**

`public`在其之后的成员在整个程序内可被访问

public成员定义类的接口

`private`之后的成员可以被类的成员函数访问

但不能被使用该类的代码访问

private成员封装了类的实现细节

`struct`和`class`的默认访问权限不同

在第一个访问说明符前 s的为public c的为private

这是它们的唯一区别

**封装：定义一系列的接口，对用户隐藏实现细节，用户在使用时只需要调用接口就可以**

**友元**

让其他类或者函数访问它的非公有成员

友元声明只能出现在类定义的内部

友元声明 不算函数声明

**封装的益处**

p242

我们通常把友元函数的声明和类放在同一个头文件

**类的其他特性**

**类成员再谈**

~~~c++
class Screen {
public:
	typedef std::string::size_type pos;
private:
	pos cursor = 0;
	pos height = 0, width = 0;
	std::string contents;
};
~~~

**令成员作为内联函数**

无需再声明和定义的地方同时说明inline

最好只再类外部定义的地方说明inline

**重载成员函数**

与重载非成员函数类似

**可变数据成员**

一个可变数据成员不会时const 即使它是const对象的成员

因此一个const成员函数可以改变一个可变成员的值

`只需在声明前加上 mutable`

**类数据成员的初始值**

当类中包含类的数据成员时

我们希望这个数据成员默认初始化

cpp11中把这个默认值声明成一个 *类内初始值*

~~~c++
class Window_mgr{
private:
    std::vector <Screen> screens{Screen(24,80,' ')};
};
~~~

类内初始值要用=号或者{}直接初始化

**返回*this的成员函数**

成员函数的返回值类型是类的引用 也就是对象本身 是个左值

其实就可以把对象的成员函数的几个调用写在同一条语句上

`myScreen.move(4,0).set('#');`

如果返回值类型是类类型 那么就是需要一个类类型的对象来接收

且调用set只能改变临时副本 并不能改变原对象的值

**const 成员函数返回*this**

令成员函数为const this是一个指向const的指针 *this是const对象

如果这个函数以引用的形式返回*this 它的返回类型是常量引用

**基于const的重载**

通过区分成员函数是否是const的 

也就是底层const 原因和之前根据指针参数是否指向const原因差不多

因为非常量版本的函数对于常量对象是不可用的 所有我们只能在一个常量对象上调用const成员函数

另一方面 虽然可以在非常量对象上调用const成员函数 但此时非常量版本是一个更好的匹配

**当一个成员调用另外一个成员时 this 指针在其中隐式地传递**

注意有可能从非常量的指针 转换为指向常量的指针

**建议：对于公共代码使用私有功能函数**

原因p248

**类类型**

每个类定义了唯一的类型

哪怕两个类的成员完全一样 

它们也是不同的类型

**类的声明**

可以把声明和定义分开

一个类的成员不能是类自己

允许包含指向它自身类型的引用或指针

**友元再探**

类可以把非成员函数（包括其他类的成员函数）和其他类定义为友元

友元函数只能定义在

**类之间的友元关系**

如果一个类指定了友元类 则友元类的成员函数可以访问此类包括非公有成员在内的所有成员

A类指定B类为友元 那么B类可以访问A类中的所有成员

*友元不具有传递性*

*每个类负责控制自己的友元*

**令成员函数作为友元**

除了令一整个类为友元外

一个类还可以令其他类中的要给单独的成员函数提供访问权限

当把一个成员函数声明成友元时

我们必须明确指出该成员函数属于哪个类

*注意定义和声明的顺序*

**函数重载和友元**

如果类想把一组函数声明成它的友元 则需要一个个的声明

**友元声明和作用域**

友元声明不算真正的函数声明

**类的作用域**

作用域运算符

**作用域和定义在类外部的成员**

~~~c++
void Window_mgr::clear(ScreenIndex i)
{
    Screen &s=screen[i];
    s.contents=string(s.height*s.width,' ');
}//必须先提供类名
~~~

~~~c++
Window_mgr::Index
Window_mgr::addScreen(const Screen &s)
{
    //返回类型出现在类名之前 所有其实是位于类作用域之外的
}
~~~

**名字查找与类的作用域**

编译器处理完类中全部的声明后才会处理成员函数的定义（函数体）

这也是为什么它能够使用类中定义的任何名字

**用于类成员声明的名字查找**

如果类内的函数的返回类型在这条声明前找不到

那么会在定义了类的作用域中查找

注意同名作用域的覆盖问题

**类型名要特殊处理**

内层作用域重新定义外层作用域中的名字

在类中

如果成员使用了外层作用域中的名字 而该名字代表一种类型

则类不能在之后重新定义该名字

类型名的定义通常出现在类的开始处

**成员定义中的普通块作用域的名字查找**

成员函数中使用的名字

1. # 在成员函数内查找该名字的声明，只有在函数使用之前出现的声明才被考虑

2. 如果1。没有找到 则在类内所有成员的地方考虑

3. 2.没有找到 **在成员函数定义之前的作用域**内继续查找

p256很典型的一种说明

**类作用域之后 在外围的作用域中查找**

成员函数中依旧可以用作用域运算符来使用被隐藏的外层同名变量

**在文件中名字的出现处对其进行解析**

**构造函数再探**

**构造函数的初始值列表**

其实是定义后立即初始化

在初始值列表写是这个

在函数体内写是先定义后赋值

初始化          赋值

**构造函数的初始值有时必不可少**

如果成员是const或者引用的话必须将其初始化

如果一个类没有定义默认构造函数

也必须将类中成员进行初始化

构造函数体一开始执行 初始化就完成了

所以初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值

别忘了某种未提供默认构造函数的类类型也是

在此时为 *这些成员*提供初值

**建议：使用构造函数初始值**

在很多类中 初始化和赋值的区别关乎底层效率问题 前者直接初始化数据成员

后者先初始化再赋值

**成员初始化的顺序**

成员初始化顺序（在构造函数初始值列表中）与它们在类的定义中的出现顺序一致

所以在列表里顺序无要求

但

如果要用一个成员来初始化另一个成员

```c++
class X{
    int i;
    int j;
    public:
    X(int val):j(val),i(j){}//错误的
}；
```

因为i先初始化

所以 最好令构造函数初始值顺序和成员声明顺序一致

**默认实参和构造函数**

默认实参在构造函数里可以起到提供默认构造函数的作用

如果一个构造函数为所有参数都提供了默认实参 则它实际上也定义了默认构造函数

**委托构造函数**

c++pp扩展

定义委托构造函数

```c++
Sales_data(string s, int cnt ,double price):bookNo(s),sold(cnt),revenue(cnt*price){}//非委托构造函数

//委托构造函数
Sales_data():Sales_data(" ",0,0){}
Sales_data(string s):Sales_data(s,0,0){}
Sales_data(istream &is): Sales_data()
{
  	read(is,*this);
}
```

**默认构造函数的作用**

当对象被默认初始化或值初始化时自动执行默认构造函数

默认初始化发生的情况 p262

**使用默认构造函数**

~~~c++
Sales_data obj();			//这是返回一个类的函数
//当你想用空括号来表示默认初始化的对象
//正确的方法时去掉空的括号
//它就会默认初始化了
~~~

~~~c++
vector<NoDefault> vec(10);
//非法，因为vector的10个元素没有被初始化，因此需要默认初始化，而NoDefault类型没有提供默认构造函数
~~~

**隐式的类类型转换**

**转换构造函数**

只接受一个实参

实际上定义了转换为此类类型的隐式转换机制

*************************************************

~~~c++
string null_book="9-999-9999-9";
//构造一个临时的Sales_data对象
//该对象的units_sold和revenue为0 bookNo等于null_book
item.combine(null_book);
~~~

这里combine的调用是合法的

编译器用给定的string自动创建了一个Sales_data对象

这个临时对象被传递给所调用函数 因为combine的参数是一个常量引用 所以我们可以给该参数传递一个临时量

**只允许一部类类型转换**

~~~c++
item.combine("9-999-9999-9");//错误的
//这是从字符串常量转换到string 然后再转换到Sales_data
//但可以这样
item.combine(string("9-999-9999-9"));
item.combine(Sales_data("9-999-9999-9"));
~~~

**类类型转换不算总有效**

**抑制构造函数定义的隐式转换**

`explicit`

~~~c++
explicit +构造函数声明
~~~

可组织隐式转换

这个关键字只对一个实参的构造函数有效

且只能在类内声明构造函数时使用

类外部定义时不应重复

**explicit构造函数只能用于直接初始化**

~~~c++
Sales_data item2=null_book;  //隐式转换
//当有如上关键字 这样就不行 
//也就是说 只能进行直接初始化 （）形式
~~~

**为转换显示地使用构造函数**

显示地强制进行转换

~~~c++
item.combine(Sales_data(null_book));
item.combine(static_cast<Sales_data>(cin));
~~~

**标准库中含有显示构造函数的类**

p266有关explicit的习题

**聚合类**

c的普通结构体就是一个聚合类

它的成员都是public

没有定义任何构造函数

没有类内初始值

没有基类

初始化同c

有值初始化

聚合类的花括号初始方式

在普通类不适用

**字面值常量类**

数据成员都是字面值类型的聚合类是字面值常量类型

如果不是聚合类

p267定义了

**类的静态成员**

**声明静态成员**

加上static 使成员与类本身关联

也就是说为所有对象所共享

它们不包含this指针

作为结果 它不能被声明成const的

也不能在static函数体中使用this指针

无论是显式还是隐式

**使用类的静态成员**

与使用普通成员一样

且成员函数不用通过作用域运算符就能直接使用静态成员

**定义静态成员**

在类外部定义静态成员不能重复static关键字

该关键字只能出现在类内部的声明语句

静态数据成员不由构造函数初始化

必须在类外部定义和初始化每个静态成员

且只能定义一次

类似于全局变量的生命周期

~~~c++
double Account::interestRate=initRate();
//initRate() 是类私有的 但可以用它  //类名出现在变量名前
//之后的作用域在类内
//interestRate的定义也可访问类的私有成员
~~~

**静态成员的类内初始化**

仅使用于constexpr类型的静态成员

详见p271

**静态成员能用于某些场景 而普通成员不能**

静态成员可以为不完全类型 可以为它的类类型

而普通成员却不行

而且静态成员可以作为默认实参

> 类的静态成员与类本身直接相关，而不是与类的各个对象关联。
>
> 优点：每个对象都不需要单独存储静态成员变量，一旦静态成员改变了，则每个对象都可以使用新的值。
>
> 区别：类的静态成员属于类本身，在类加载时就会分配内存，可以通过类名直接进行访问。
>
> 普通成员属于类的对象，只有在类对象产生时才会分配内存。只能通过对象去访问。
