# **类**

## **基本思想**

### **数据抽象**

#### 依赖*接口*和*实现*分离的编程技术

### **封装**

实现了类的接口和实现的分离

封装后的类隐藏了它的实现细节

也就是说 类的用户只能使用接口而无法访问实现部分

**抽象数据类型ADT**

**定义成员函数**

*定义在类内部的函数是隐式的inline函数*

隐式参数`this`

`total.isbn()`

`isbn(&total)`//可以看作这样

当调用成员函数时

用请求该函数的对象地址初始化this

在成员函数内部

我们可以直接使用调用该函数的对象的成员

而无须通过成员访问运算符

任何对类成员的直接访问都被看作this的隐式引用

就是当isbn函数使用一个成员时 如`bookno`

如同 `this->bookno`

*`this`为常量指针*

**引入const成员函数**

`const`作用修改隐式this指针的类型

默认情况

`this`的类似是指向类类型非常量版本的常量指针

`类名 *const this`

即我们在默认情况下 不能把this绑定到一个常量对象上

在成员函数的参数列表 （）之后加上 `const`这样 this就成了指向常量的指针

提高了灵活性

这样使用const的成员函数 为 *常量成员函数*

常量对象 以及常量对象的引用或指针都只能调用常量成员函数

**类作用域和成员函数**

类本身就是一个作用域

即使成员变量定义在成员函数之后

成员函数还是能使用之后的成员变量

这是因为编译器先编译成员的声明 然后才轮到成员函数体

无需在意它们的次序

**在类的外部定义成员函数**

如果是常量成员函数别忘了const

属于类作用域

隐式使用了成员

**定义一个返回this对象的函数**

`return *this`

返回的是对象的引用 如果要求是左值的话

**定义类相关的非成员函数**

这些函数从概念上来说属于类的接口的组成部分

它们实际上并不属于类本身

如果函数概念上属于类 但不定义在类中 它一般应与类声明（而非定义）

在同一个头文件中 

`IO类`不能被拷贝 要用引用

读写会改变其内容 是普通引用

`read()`  `print()` 函数

**构造函数**

用来控制其对象的初始化方式

只要类的对象被创建 就会执行构造函数

*构造函数的名字和类名相同*

*没有返回类型*！！！

*可以有多个构造函数 类似重载函数*

*不能被声明成const  在构造函数完成初始化后 声明为const的对象才获得const属性*

**合成的默认构造函数**

类没有构造函数

没有为对象提供初始值

其实类通过一个特殊的构造函数来控制默认初始化过程

这个函数叫 **默认构造函数**

它无须任何实参

没有显式的定义构造函数

编译器会隐式的定义个默认构造函数

又被称为 **合成的默认构造函数**

按照如下规则初始化类的数据成员：

> 如果存在类内的初始值 则用它来初始化成员
>
> 否则 默认初始化该成员

**某些类不能依赖于合成的默认构造函数**

p236的三个原因

> 如果类包含有内置类型或者复合类型的成员 则只有当这些成员全都被赋予了
>
> 类内的初始值时 这个类才适合于使用合成的默认构造函数

~~~c++
struct Sales_data {
	Sales_data() = default;
	Sales_data(const std::string &s):bookNo(s){}
	Sales_data(const std::string &s, unsigned n, double p):
		bookNo(s),units_sold(n),revenue(p*n){}
	Sales_data(std::istream&);
	std::string isbn() const { return bookNo; }
	Sales_data combine(const Sales_data&);
	double avg_price() const;
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
~~~



**= default 的含义**

cpp11中 如果我们需要默认的行为 那么可以通过在参数列表后面写上

`= default`来要求编译器生成构造函数

它既可以和声明一起出现在类的内部 也可以作为定义出现在类的外部

如果已经有了一个自己给定的构造函数 那么这个构造函数时必须的（default）

注意函数的内联问题

**构造函数初始值列表**

~~~c++
Sales_data(const std::string &s):bookNo(s){}
	Sales_data(const std::string &s, unsigned n, double p):
		bookNo(s),units_sold(n),revenue(p*n){}
~~~

> 冒号以及冒号和花括号之间的代码

这就是 *构造函数初始值列表*

它负责为新创建的对象的一个或几个数据成员赋初值

它是成员名字的一个列表

每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值

不同成员的初始化通过逗号分割开来

对没有显式初始化的成员会与合成默认构造函数相同的方式隐式初始化

上面的两个构造函数中的函数体都是空的 这是因为这些构造函数的唯一目的就是为数据成员赋初值

**在类的外部定义的构造函数**

~~~c++
	Sales_data(std::istream&);
~~~

以输入流为参数的构造函数 需要执行一些实际的操作

在它的函数体内 调用了read函数以给数据成员赋初值

**构造函数没有返回类型**

**拷贝 赋值 析构**

类不定义这些功能 编译器会进行对对象的每个成员进行赋值 拷贝 销毁

**某些类不能依赖于合成的版本**

如构造体（类）中成员额外开辟的动态内存

当一个对象含有vector或者string成员 可以正常进行

**访问控制与封装**

**访问说明符**

`public`在其之后的成员在整个程序内可被访问

public成员定义类的接口

`private`之后的成员可以被类的成员函数访问

但不能被使用该类的代码访问

private成员封装了类的实现细节

`struct`和`class`的默认访问权限不同

在第一个访问说明符前 s的为public c的为private

这是它们的唯一区别

**封装：定义一系列的接口，对用户隐藏实现细节，用户在使用时只需要调用接口就可以**

**友元**

让其他类或者函数访问它的非公有成员

友元声明只能出现在类定义的内部

友元声明 不算函数声明

**封装的益处**

p242

我们通常把友元函数的声明和类放在同一个头文件

**类的其他特性**

**类成员再谈**

~~~c++
class Screen {
public:
	typedef std::string::size_type pos;
private:
	pos cursor = 0;
	pos height = 0, width = 0;
	std::string contents;
};
~~~

**令成员作为内联函数**

无需再声明和定义的地方同时说明inline

最好只再类外部定义的地方说明inline

**重载成员函数**

与重载非成员函数类似

**可变数据成员**

一个可变数据成员不会时const 即使它是const对象的成员

因此一个const成员函数可以改变一个可变成员的值

`只需在声明前加上 mutable`

**类数据成员的初始值**

当类中包含类的数据成员时

我们希望这个数据成员默认初始化

cpp11中把这个默认值声明成一个 *类内初始值*

~~~c++
class Window_mgr{
private:
    std::vector <Screen> screens{Screen(24,80,' ')};
};
~~~

类内初始值要用=号或者{}直接初始化

**返回*this的成员函数**

成员函数的返回值类型是类的引用 也就是对象本身 是个左值

其实就可以把对象的成员函数的几个调用写在同一条语句上

`myScreen.move(4,0).set('#');`

如果返回值类型是类类型 那么就是需要一个类类型的对象来接收

