**函数基础**

函数返回不能是数组类型，不能是函数类型

可以是数组指针 函数指针

**作用域 生命周期**

**自动对象**

只存在于块执行期间的对象

**局部静态对象**

内置类型的局部静态变量隐式初始化为0

**函数声明 函数原型**

**参数传递**

引用传递 值传递

**const形参与实参**

初始化会忽略顶层const

~~~c++
    int i = 42;
    const int* cp = &i;
    const int& r = i;
    const int& r2 = 42;     //可以使用非常量初始化一个底层const对象，反之不行
    int* p = cp;   //err
    int& r3 = r;    //err
    int& r4 = 42;   //err
~~~

**尽量使用常量引用**

我们不能把const对象，字面值或者需要类型转换的对象传递给普通的引用形参

**数组形参**

数组的引用

**main 处理命令行选项**

**含有可变形参的函数**

为了编写能处理不同数量实参的函数 标准11提供了两种主要的方法

如果所有的实参类型相同 可以传递一个名为`initializer_list`的标准库类型，如果所有的实参类型不同，我们可以编写一种特殊的函数 也就是所谓的可变参数模板。

*省略符形参*

initializer_list定义在同名头文件中

是一种模板类型

~~~c++
void error_list(initializer_list <string> il)
{
    for (auto beg = il.begin(); beg != il.end(); ++beg)
    {
        cout << *beg << " ";
    }
    cout << endl;
}
int main()
{
    error_list({ "haha","hehe","xixi" });
    return 0;
}
~~~

**省略符形参**

用于访问C代码而设置的

这些代码使用了名为varargs的C标准库功能

**返回类型和return语句**

void函数也可以返回一个表达式，这个表达式必须是另一个void函数

**值是如何返回的**

非引用会返回副本或者未命名的临时对象

**不要返回局部对象的引用或指针**

函数的返回类型决定函数调用是否是左值

返回一个引用的函数得到左值其他返回类型得到右值

~~~c++
char & get_val(string& str, int ix)
{
    return str[ix];
}
int main()
{
    string s = "haha";
    get_val(s, 1) = 'e';
    cout << s;
    return 0;
}
~~~

c11规定函数可以返回花括号包围的值的列表

如果函数返回的是内置类型 则花括号包围的最多一个值

如果是类 由其定义初始值如何使用

**返回数组指针**

~~~c++
typedef int arr[10];
using arr = int[10];
~~~

**尾置返回类型**

~~~c++
auto func(int i) -> int(*)[10];//尾置返回类型
~~~

**使用decltype**

~~~c++
int odd[] = { 1,3,5,7,9 };
int even[] = { 2,4,6,8,10};
decltype(odd)* arrPtr(int i)
{
    return (i % 2) ? &odd : &even;  //返回一个指向数组的指针
}
~~~

**重载函数**

如果在同一作用域内的几个函数名字相同但形参列表不同，我们称之为

*重载函数*

~~~c++
void print(const char*);
void print(const int* beg, const int* end);
void print(const int ia[], size_t size);
~~~

*main函数不能重载*

要么形参类型不同，要么形参个数不同

只有返回类型不同是不行的

有无顶层const都是一样的 没有区分开

但对于指针和引用来说 通过区分其指向是常量对象还是非常量对象

可以实现函数重载 此时的const是底层的

~~~c++
void print(const char);
void print(char);           //重复声明

void print( char*);
void print(char const);      //重复声明
~~~

~~~c++
void print(const char*);
void print(char *);      //新函数

void print(const char&);
void print( char&);		//新函数
~~~

编译器通过实参是否是常量来推断调用哪个函数

因为const不能转换成其他类型

相反的 因为非常量可以转换为const 所以上面四个都可以作为其调用对象

不过编译器会优先选择非常量版本的函数

**const_cast和重载**

const_cast见第四章

~~~c++
const string& shorterString(const string& s1, const string& s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}

string& shorterString(string& s1, string& s2)
{
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));  //将函数的实参强制转换为const
    //因为其本就绑定在一个实体string上
    //再转换为普通的引用当然正确
    return const_cast<string&>(r);
}
~~~

**函数匹配 重载确定**

三种情况

**最佳匹配**

**无匹配**

**二义性调用**

