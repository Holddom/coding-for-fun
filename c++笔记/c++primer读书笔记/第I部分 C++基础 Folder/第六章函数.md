**函数基础**

函数返回不能是数组类型，不能是函数类型

可以是数组指针 函数指针

**作用域 生命周期**

**自动对象**

只存在于块执行期间的对象

**局部静态对象**

内置类型的局部静态变量隐式初始化为0

**函数声明 函数原型**

**参数传递**

引用传递 值传递

**const形参与实参**

初始化会忽略顶层const

~~~c++
    int i = 42;
    const int* cp = &i;
    const int& r = i;
    const int& r2 = 42;     //可以使用非常量初始化一个底层const对象，反之不行
    int* p = cp;   //err
    int& r3 = r;    //err
    int& r4 = 42;   //err
~~~

**尽量使用常量引用**

我们不能把const对象，字面值或者需要类型转换的对象传递给普通的引用形参

**数组形参**

数组的引用

**main 处理命令行选项**

**含有可变形参的函数**

为了编写能处理不同数量实参的函数 标准11提供了两种主要的方法

如果所有的实参类型相同 可以传递一个名为`initializer_list`的标准库类型，如果所有的实参类型不同，我们可以编写一种特殊的函数 也就是所谓的可变参数模板。

*省略符形参*

initializer_list定义在同名头文件中

是一种模板类型

~~~c++
void error_list(initializer_list <string> il)
{
    for (auto beg = il.begin(); beg != il.end(); ++beg)
    {
        cout << *beg << " ";
    }
    cout << endl;
}
int main()
{
    error_list({ "haha","hehe","xixi" });
    return 0;
}
~~~

**省略符形参**

用于访问C代码而设置的

这些代码使用了名为varargs的C标准库功能

**返回类型和return语句**