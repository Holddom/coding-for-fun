**同C的组合运算符和运算对象**

**运算对象转换**

**不在赘述**

**C++的重载运算符**

> 当运算符作用于类类型时 用户可以自行定义其含义
>
> 是为已存在的运算符赋予另一层含义
>
> 故为重载运算符

在重载运算符时 运算对象的类型和返回值的类型都是运算符定义的

运算对象的个数和运算符优先级和结合律都是无法改变的

**左值和右值**

不完全同于C

详见《C和指针》对他们的描述

左值有实际的存储空间

特别知道 / % 负数运算规律

**逻辑运算符**

**短路求值 懒惰求值**

**关系运算符**

**赋值运算符**

**复合赋值运算符求值只一次**

**递增递减运算符**

**除非必须 否则不用递增递减运算符的后置版本**

**箭头运算符 点运算符**

箭头运算符的结果是一个左值 

点运算符看成员对象是左值还是右值

**三目条件运算符**

可以嵌套

优先级很低 要加括号

**位运算符**

现在不看

**sizeof运算符**

不实际计算其运算对象的值！！！

对引用 对指针 对解引用 搞懂

对数组 对string和vector对象只返回该类型固定部分的大小 不会计算对象中元素占用了多少空间

**类型转换**

隐式转换

算术转换

整型提升

数组转换成指针

转换成布尔

引用常量 指针常量的转换

显示转换

`static_cast`任何具有明确定义的类型转换 只要不包含底层const 都可以使用static_cast 

~~~c++
    int i = 5;
    int j = 2;
    double slope = static_cast <double>(i) / j;
~~~

`const_cast`只能改变运算对象的底层const

去掉const性质 只改变常量属性

常常用于**函数重载**的上下文中

`reinterpret_cast`

通常位运算对象的位模式提供较低层次上的重新解释

~~~c++
    int* ip;
    char* pc = reinterpret_cast<char*> (ip);
	//等价下条语句
	char* pc = (char*) ip
~~~

旧式强制类型转换