讲了数据类型，常量变量，初始化，声明，typedef
#define const 的用法


	• 作用域：编译器可以确认4种不同类型的作用域：文件，函数，代码块，原型
代码块嵌套时内部的标识符作用域到达该代码块的尾部便终止
如果内部与外部同名，内层的标识符就将隐藏外层的标识符，即外层同名无法在内层通过名字访问。
文件作用域是指在代码块之外的声明的标识符 他们的作用域从声明处到源文件结尾处
函数名不属于任何代码块，通过include的使用它的作用域不局限于头文件的文件尾 函数的存储类型总是在静态内存，这为递归提供了条件
函数原型中的名字可有可无，它们只在函数原型的起作用
链接属性external可以在不同文件使用同一个变量
函数名和全局变量的链接属性都是external
	• static关键字可以使它的链接属性变为internal
即为该源文件私有的变量，同样可以对函数使用
	• ertern关键字则相反
变量的存储类型：普通内存，运行时堆栈，硬件寄存器。
任何在代码块之外声明的变量总是存储与静态内存中，成为静态static变量，它在程序运行之前创建，在程序的整个执行期间始终存在。它始终保持原先的值。
除非给它赋一个不同的值或者程序结束。
代码块内部声明的变量是自动auto变量，它存储于堆栈中。
修改变量的存储类型并不表示修改该变量的作用域，它仍然只能在该代码块内部按名字访问。函数的形式参数不能声明为静态，因为实参总是在堆栈中传递给函数，用于支持递归。
	• 关键字register可以用于自动变量的声明，提示它们应该存储于机器的硬件寄存器，这类变量为寄存器变量。比存储于内存的变量访问的效率更高。但有时候是编译器决定哪些变量应该存储在寄存器中（频率最高的？）
	• 自动变量的先声明后赋值和同时进行没有效率上的差别
	• static关键字 当他用于函数定义或代码块以外的变量声明，static用于修改标识符的链接属性（不同文件），存储类型和作用域不受影响
        当它在代码块内部使用，就用于修改变量的存储类型，从auto变为static，但链接属性和作用域不受影响。
	• 所以对于声明来说，我们需要注意变量的作用域、链接属性和存储类型。
	• 具有external链接属性的实体就是全局实体
	• 只要变量并非声明于代码块内部或函数定义内部，它在所缺省的情况下链接属性即为external。
	• external的实体总是具有静态存储类型 全局变量在程序开始执行前创建，并在程序整个执行过程中存在
而局部变量的生命周期是函数的调用过程，在缺省的存储类型为auto 原因之一是需要时分配存储会节省空间，其二是在堆栈上分配存储可以有效地实现递归