以后不同类型的算法题 总结最好 ---2022.11.11



6324

c++中有内置的lcm函数 （求最小公倍数）[最小公倍数为 K 的子数组数目](https://leetcode.cn/submissions/detail/381735803/)

注意不剪枝就会爆int （还有0n的写法）



6235

类似冒泡排序的只能相邻交换的排序 跟逆序数有关 交换次数等于逆序对数

而求一个序列从有序到无序的最少交换次数 可以用离散化（映射） 置换环的性质解决

置换环的次数为每个环的大小减一



如何将一个无序互不相等的数组离散化

首先存储排好序的拷贝

然后每次用二分找到对应值应该在排过序的数组对应的下标（映射）

在处理环 （用数组中的数当作下标）的时候 要保证每个下标仅被访问一次（标记下标）





115. 不同的子序列

    关于字符串匹配，通常有两种（你也可以理解为一种）通用的状态定义：
    
    f[i][j]f[i][j]f[i][j] 表示「第一个字符 s 中 [0,i][0,i][0,i] 个字符」与「第二个字符 t 中 [0,j][0,j][0,j] 个字符」的匹配结果
    f[i][j]f[i][j]f[i][j] 表示「第一个字符 s 中 [0,i][0,i][0,i] 个字符」与「第二个字符 t 中 [0,j][0,j][0,j] 个字符」且 「最后一个字符为 t[j]」的匹配结果
    
    往两个字符串的头部追加「不存在」的字符，目的是为了能够构造出可以滚动（被累加）下去的初始化值



516.最长回文子序列

区间DP

可以枚举区间长度len 然后枚举左端点 这样就能得到右端点

这样做 区间是从小到大的 小的状态先被计算

还有就是从后往前枚举i 再从前往后枚举j

这样也能保证[i,j] 的区间长度由小到大

对于这题也可以 	逆序字符串转换成LCS问题
