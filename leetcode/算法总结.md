以后不同类型的算法题 总结最好 ---2022.11.11



6324

c++中有内置的lcm函数 （求最小公倍数）[最小公倍数为 K 的子数组数目](https://leetcode.cn/submissions/detail/381735803/)

注意不剪枝就会爆int （还有0n的写法）



6235

类似冒泡排序的只能相邻交换的排序 跟逆序数有关 交换次数等于逆序对数

而求一个序列从有序到无序的最少交换次数 可以用离散化（映射） 置换环的性质解决

置换环的次数为每个环的大小减一



如何将一个无序互不相等的数组离散化

首先存储排好序的拷贝

然后每次用二分找到对应值应该在排过序的数组对应的下标（映射）

在处理环 （用数组中的数当作下标）的时候 要保证每个下标仅被访问一次（标记下标）





115. 不同的子序列

    关于字符串匹配，通常有两种（你也可以理解为一种）通用的状态定义：
    
    f[i][j]f[i][j]f[i][j] 表示「第一个字符 s 中 [0,i][0,i][0,i] 个字符」与「第二个字符 t 中 [0,j][0,j][0,j] 个字符」的匹配结果
    f[i][j]f[i][j]f[i][j] 表示「第一个字符 s 中 [0,i][0,i][0,i] 个字符」与「第二个字符 t 中 [0,j][0,j][0,j] 个字符」且 「最后一个字符为 t[j]」的匹配结果
    
    往两个字符串的头部追加「不存在」的字符，目的是为了能够构造出可以滚动（被累加）下去的初始化值



516.最长回文子序列

区间DP

可以枚举区间长度len 然后枚举左端点 这样就能得到右端点

这样做 区间是从小到大的 小的状态先被计算

还有就是从后往前枚举i 再从前往后枚举j

这样也能保证[i,j] 的区间长度由小到大

对于这题也可以 	逆序字符串转换成LCS问题



664. 奇怪的打印机

这题跟516 相同 都为区间dp

但多了一重循环 因为状态转移 本题需要我们分成两段更小的区间去考虑

共三重循环



775. 全局倒置与局部倒置

对这题要仔细分析题干的两个定义 找出他们之间的练习

只需判断它们的个数是否相等 而不是要求出个数



[730. 统计不同回文子序列](https://leetcode.cn/submissions/detail/382876718/)

数据量大 匹配考虑哈希和二分

多指针



周赛二叉搜索树

6242. 二叉搜索树最近节点查询

数据量大 （最坏情况是个单链表 on的复杂度）

 转换到有序数组二分



467. 环绕字符串中唯一的子字符串

这题是序列DP 状态是以某字母结尾的子串个数



808. 分汤

这题在数据很大的情况下 对于A事件的概率接近1 

计算事件A的期望比B的期望大

在转化为DP状态时%25

递推的边界条件也很有意思 就是当A B分别剩下 i j份 的概率



lcm最小公倍数 

gcd 最大公约数





**这里简单说下「线性 DP」和「序列 DP」的区别。**

线性 DP 通常强调「状态转移所依赖的前驱状态」是由给定数组所提供的，即拓扑序是由原数组直接给出。更大白话来说就是通常有 f[i][...]f[i][...]f[i][...] 依赖于 f[i−1][...]f[i - 1][...]f[i−1][...]。

这就限定了线性 DP 的复杂度是简单由「状态数量（或者说是维度数）」所决定。

序列 DP 通常需要结合题意来寻找前驱状态，即需要自身寻找拓扑序关系（例如本题，需要自己结合题意来找到可转移的前驱状态 f[i−m]f[i - m]f[i−m]）。

这就限定了序列 DP 的复杂度是由「状态数 + 找前驱」的复杂度所共同决定。也直接导致了序列 DP 有很多玩法，往往能够结合其他知识点出题，来优化找前驱这一操作，通常是利用某些性质，或是利用数据结构进行优化。



字符串哈希 二分仍需学习--22.11.22





DP之LIS -- 最长上升子序列 可优化为nlogn



795.区间子数组的个数

贡献的思想



2104. 子数组范围和

单调栈 看细节处理 边界个数取 -1或者n

重复的元素 有一次不取等号111



今天准备考试 明天潜心修炼

